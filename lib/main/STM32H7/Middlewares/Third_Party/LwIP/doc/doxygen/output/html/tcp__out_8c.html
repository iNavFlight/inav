<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>lwIP: src/core/tcp_out.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">lwIP
   &#160;<span id="projectnumber">2.1.2</span>
   </div>
   <div id="projectbrief">Lightweight IP stack</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('tcp__out_8c.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">tcp_out.c File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &quot;<a class="el" href="opt_8h.html">lwip/opt.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="tcp__priv_8h.html">lwip/priv/tcp_priv.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="def_8h.html">lwip/def.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="mem_8h.html">lwip/mem.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="memp_8h.html">lwip/memp.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="ip__addr_8h.html">lwip/ip_addr.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="netif_8h.html">lwip/netif.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="inet__chksum_8h.html">lwip/inet_chksum.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="stats_8h.html">lwip/stats.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="ip6_8h.html">lwip/ip6.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="ip6__addr_8h.html">lwip/ip6_addr.h</a>&quot;</code><br />
<code>#include &lt;string.h&gt;</code><br />
<code>#include &quot;path/to/my/lwip_hooks.h&quot;</code><br />
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a25d7e9081baa5c84f2ebd34b0eb4169b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tcp__out_8c.html#a25d7e9081baa5c84f2ebd34b0eb4169b">TCP_CHECKSUM_ON_COPY_SANITY_CHECK</a>&#160;&#160;&#160;0</td></tr>
<tr class="separator:a25d7e9081baa5c84f2ebd34b0eb4169b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2ef22d2384225a1b5fee187411cc129"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tcp__out_8c.html#aa2ef22d2384225a1b5fee187411cc129">TCP_OVERSIZE_CALC_LENGTH</a>(length)&#160;&#160;&#160;((length) + <a class="el" href="group__lwip__opts__tcp.html#ga5648e2580bb55c0efdfbebcf3bad1eef">TCP_OVERSIZE</a>)</td></tr>
<tr class="separator:aa2ef22d2384225a1b5fee187411cc129"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga6b2aa0efbf10e254930332b7c89cd8c5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__infrastructure__errors.html#gaf02d9da80fd66b4f986d2c53d7231ddb">err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tcp__raw.html#ga6b2aa0efbf10e254930332b7c89cd8c5">tcp_write</a> (struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *pcb, const void *arg, u16_t len, u8_t apiflags)</td></tr>
<tr class="separator:ga6b2aa0efbf10e254930332b7c89cd8c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac930859c4e4ad9fcf6bb25ef5e91bcd5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__infrastructure__errors.html#gaf02d9da80fd66b4f986d2c53d7231ddb">err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tcp__out_8c.html#ac930859c4e4ad9fcf6bb25ef5e91bcd5">tcp_split_unsent_seg</a> (struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *pcb, u16_t split)</td></tr>
<tr class="separator:ac930859c4e4ad9fcf6bb25ef5e91bcd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af40ba9d645a8910436c3d7cf13dba342"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__infrastructure__errors.html#gaf02d9da80fd66b4f986d2c53d7231ddb">err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tcp__out_8c.html#af40ba9d645a8910436c3d7cf13dba342">tcp_send_fin</a> (struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *pcb)</td></tr>
<tr class="separator:af40ba9d645a8910436c3d7cf13dba342"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7d5d552647d567095876aab202bfd1a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__infrastructure__errors.html#gaf02d9da80fd66b4f986d2c53d7231ddb">err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tcp__out_8c.html#aa7d5d552647d567095876aab202bfd1a">tcp_enqueue_flags</a> (struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *pcb, u8_t flags)</td></tr>
<tr class="separator:aa7d5d552647d567095876aab202bfd1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0cbcc6d628f644a530daf629fa3e5f7f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__infrastructure__errors.html#gaf02d9da80fd66b4f986d2c53d7231ddb">err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tcp__raw.html#ga0cbcc6d628f644a530daf629fa3e5f7f">tcp_output</a> (struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *pcb)</td></tr>
<tr class="separator:ga0cbcc6d628f644a530daf629fa3e5f7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f318930bd6d49074343cc79c5166f39"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__infrastructure__errors.html#gaf02d9da80fd66b4f986d2c53d7231ddb">err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tcp__out_8c.html#a1f318930bd6d49074343cc79c5166f39">tcp_rexmit_rto_prepare</a> (struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *pcb)</td></tr>
<tr class="separator:a1f318930bd6d49074343cc79c5166f39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ef9dc094e21bdf0779aed25ab0b08d4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tcp__out_8c.html#a9ef9dc094e21bdf0779aed25ab0b08d4">tcp_rexmit_rto_commit</a> (struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *pcb)</td></tr>
<tr class="separator:a9ef9dc094e21bdf0779aed25ab0b08d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5ef9c8ab4629eb721987ae316b9f30f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tcp__out_8c.html#ab5ef9c8ab4629eb721987ae316b9f30f">tcp_rexmit_rto</a> (struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *pcb)</td></tr>
<tr class="separator:ab5ef9c8ab4629eb721987ae316b9f30f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af75fefe4fe509845be156d6e424eb6f1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__infrastructure__errors.html#gaf02d9da80fd66b4f986d2c53d7231ddb">err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tcp__out_8c.html#af75fefe4fe509845be156d6e424eb6f1">tcp_rexmit</a> (struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *pcb)</td></tr>
<tr class="separator:af75fefe4fe509845be156d6e424eb6f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb6ee7b4d59f125cc8bfac3bb5ca3937"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tcp__out_8c.html#adb6ee7b4d59f125cc8bfac3bb5ca3937">tcp_rexmit_fast</a> (struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *pcb)</td></tr>
<tr class="separator:adb6ee7b4d59f125cc8bfac3bb5ca3937"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa90f8051c9633d3017c588245cdc4014"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tcp__out_8c.html#aa90f8051c9633d3017c588245cdc4014">tcp_rst</a> (const struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *pcb, u32_t seqno, u32_t ackno, const <a class="el" href="group__ipaddr.html#ga16ef96d6cde029029bbf47fee35fd67a">ip_addr_t</a> *local_ip, const <a class="el" href="group__ipaddr.html#ga16ef96d6cde029029bbf47fee35fd67a">ip_addr_t</a> *remote_ip, u16_t local_port, u16_t remote_port)</td></tr>
<tr class="separator:aa90f8051c9633d3017c588245cdc4014"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefde3e34b2cc8df9654986484c44a996"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__infrastructure__errors.html#gaf02d9da80fd66b4f986d2c53d7231ddb">err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tcp__out_8c.html#aefde3e34b2cc8df9654986484c44a996">tcp_send_empty_ack</a> (struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *pcb)</td></tr>
<tr class="separator:aefde3e34b2cc8df9654986484c44a996"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d8bb5fc8522515aa35d305774cc5332"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__infrastructure__errors.html#gaf02d9da80fd66b4f986d2c53d7231ddb">err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tcp__out_8c.html#a0d8bb5fc8522515aa35d305774cc5332">tcp_keepalive</a> (struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *pcb)</td></tr>
<tr class="separator:a0d8bb5fc8522515aa35d305774cc5332"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c20490aa45c771c38ce8ad3031cbdf6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__infrastructure__errors.html#gaf02d9da80fd66b4f986d2c53d7231ddb">err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tcp__out_8c.html#a6c20490aa45c771c38ce8ad3031cbdf6">tcp_zero_window_probe</a> (struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *pcb)</td></tr>
<tr class="separator:a6c20490aa45c771c38ce8ad3031cbdf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Transmission Control Protocol, outgoing traffic</p>
<p>The output functions of TCP.</p>
<p>There are two distinct ways for TCP segments to get sent:</p><ul>
<li>queued data: these are segments transferring data or segments containing SYN or FIN (which both count as one sequence number). They are created as struct <a class="el" href="group__pbuf.html">Packet buffers (PBUF)</a> together with a struct tcp_seg and enqueue to the unsent list of the pcb. They are sent by tcp_output:<ul>
<li><a class="el" href="group__tcp__raw.html#ga6b2aa0efbf10e254930332b7c89cd8c5">tcp_write</a> : creates data segments</li>
<li><a class="el" href="tcp__priv_8h.html#ac930859c4e4ad9fcf6bb25ef5e91bcd5">tcp_split_unsent_seg</a> : splits a data segment</li>
<li><a class="el" href="tcp__priv_8h.html#aa7d5d552647d567095876aab202bfd1a">tcp_enqueue_flags</a> : creates SYN-only or FIN-only segments</li>
<li><a class="el" href="group__tcp__raw.html#ga0cbcc6d628f644a530daf629fa3e5f7f">tcp_output</a> / tcp_output_segment : finalize the tcp header (e.g. sequence numbers, options, checksum) and output to IP</li>
<li>the various tcp_rexmit functions shuffle around segments between the unsent an unacked lists to retransmit them</li>
<li>tcp_create_segment and tcp_pbuf_prealloc allocate pbuf and segment for these functions</li>
</ul>
</li>
<li>direct send: these segments don't contain data but control the connection behaviour. They are created as pbuf only and sent directly without enqueueing them:<ul>
<li><a class="el" href="tcp__priv_8h.html#aefde3e34b2cc8df9654986484c44a996">tcp_send_empty_ack</a> sends an ACK-only segment</li>
<li><a class="el" href="tcp__priv_8h.html#aa90f8051c9633d3017c588245cdc4014">tcp_rst</a> sends a RST segment</li>
<li><a class="el" href="tcp__priv_8h.html#a0d8bb5fc8522515aa35d305774cc5332">tcp_keepalive</a> sends a keepalive segment</li>
<li><a class="el" href="tcp__priv_8h.html#a6c20490aa45c771c38ce8ad3031cbdf6">tcp_zero_window_probe</a> sends a window probe segment</li>
<li>tcp_output_alloc_header allocates a header-only pbuf for these functions </li>
</ul>
</li>
</ul>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a id="a25d7e9081baa5c84f2ebd34b0eb4169b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25d7e9081baa5c84f2ebd34b0eb4169b">&#9670;&nbsp;</a></span>TCP_CHECKSUM_ON_COPY_SANITY_CHECK</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define TCP_CHECKSUM_ON_COPY_SANITY_CHECK&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Define this to 1 for an extra check that the output checksum is valid (usefule when the checksum is generated by the application, not the stack) </p>

</div>
</div>
<a id="aa2ef22d2384225a1b5fee187411cc129"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2ef22d2384225a1b5fee187411cc129">&#9670;&nbsp;</a></span>TCP_OVERSIZE_CALC_LENGTH</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define TCP_OVERSIZE_CALC_LENGTH</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">length</td><td>)</td>
          <td>&#160;&#160;&#160;((length) + <a class="el" href="group__lwip__opts__tcp.html#ga5648e2580bb55c0efdfbebcf3bad1eef">TCP_OVERSIZE</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The size of segment pbufs created when TCP_OVERSIZE is enabled </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="aa7d5d552647d567095876aab202bfd1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7d5d552647d567095876aab202bfd1a">&#9670;&nbsp;</a></span>tcp_enqueue_flags()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__infrastructure__errors.html#gaf02d9da80fd66b4f986d2c53d7231ddb">err_t</a> tcp_enqueue_flags </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *&#160;</td>
          <td class="paramname"><em>pcb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8_t&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enqueue SYN or FIN for transmission.</p>
<p>Called by <a class="el" href="group__tcp__raw.html#ga9a31deea4cadacd39f9485f37cfdd012">tcp_connect</a>, tcp_listen_input, and <a class="el" href="group__tcp__raw.html#ga87093e137fcc53ea82a134a3f5b33623">tcp_close</a> (via <a class="el" href="tcp__priv_8h.html#af40ba9d645a8910436c3d7cf13dba342">tcp_send_fin</a>)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pcb</td><td>Protocol control block for the TCP connection. </td></tr>
    <tr><td class="paramname">flags</td><td>TCP header flags to set in the outgoing segment. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0d8bb5fc8522515aa35d305774cc5332"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d8bb5fc8522515aa35d305774cc5332">&#9670;&nbsp;</a></span>tcp_keepalive()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__infrastructure__errors.html#gaf02d9da80fd66b4f986d2c53d7231ddb">err_t</a> tcp_keepalive </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *&#160;</td>
          <td class="paramname"><em>pcb</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Send keepalive packets to keep a connection active although no data is sent over it.</p>
<p>Called by <a class="el" href="tcp_8c.html#a421fb42ef919018e14ae413adfee9905">tcp_slowtmr()</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pcb</td><td>the <a class="el" href="structtcp__pcb.html">tcp_pcb</a> for which to send a keepalive packet </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af75fefe4fe509845be156d6e424eb6f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af75fefe4fe509845be156d6e424eb6f1">&#9670;&nbsp;</a></span>tcp_rexmit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__infrastructure__errors.html#gaf02d9da80fd66b4f986d2c53d7231ddb">err_t</a> tcp_rexmit </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *&#160;</td>
          <td class="paramname"><em>pcb</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Requeue the first unacked segment for retransmission</p>
<p>Called by tcp_receive() for fast retransmit.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pcb</td><td>the <a class="el" href="structtcp__pcb.html">tcp_pcb</a> for which to retransmit the first unacked segment </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adb6ee7b4d59f125cc8bfac3bb5ca3937"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb6ee7b4d59f125cc8bfac3bb5ca3937">&#9670;&nbsp;</a></span>tcp_rexmit_fast()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tcp_rexmit_fast </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *&#160;</td>
          <td class="paramname"><em>pcb</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Handle retransmission after three dupacks received</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pcb</td><td>the <a class="el" href="structtcp__pcb.html">tcp_pcb</a> for which to retransmit the first unacked segment </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab5ef9c8ab4629eb721987ae316b9f30f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5ef9c8ab4629eb721987ae316b9f30f">&#9670;&nbsp;</a></span>tcp_rexmit_rto()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tcp_rexmit_rto </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *&#160;</td>
          <td class="paramname"><em>pcb</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Requeue all unacked segments for retransmission</p>
<p>Called by tcp_process() only, <a class="el" href="tcp_8c.html#a421fb42ef919018e14ae413adfee9905">tcp_slowtmr()</a> needs to do some things between "prepare" and "commit".</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pcb</td><td>the <a class="el" href="structtcp__pcb.html">tcp_pcb</a> for which to re-enqueue all unacked segments </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9ef9dc094e21bdf0779aed25ab0b08d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ef9dc094e21bdf0779aed25ab0b08d4">&#9670;&nbsp;</a></span>tcp_rexmit_rto_commit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tcp_rexmit_rto_commit </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *&#160;</td>
          <td class="paramname"><em>pcb</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Requeue all unacked segments for retransmission</p>
<p>Called by <a class="el" href="tcp_8c.html#a421fb42ef919018e14ae413adfee9905">tcp_slowtmr()</a> for slow retransmission.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pcb</td><td>the <a class="el" href="structtcp__pcb.html">tcp_pcb</a> for which to re-enqueue all unacked segments </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1f318930bd6d49074343cc79c5166f39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f318930bd6d49074343cc79c5166f39">&#9670;&nbsp;</a></span>tcp_rexmit_rto_prepare()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__infrastructure__errors.html#gaf02d9da80fd66b4f986d2c53d7231ddb">err_t</a> tcp_rexmit_rto_prepare </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *&#160;</td>
          <td class="paramname"><em>pcb</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Requeue all unacked segments for retransmission</p>
<p>Called by <a class="el" href="tcp_8c.html#a421fb42ef919018e14ae413adfee9905">tcp_slowtmr()</a> for slow retransmission.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pcb</td><td>the <a class="el" href="structtcp__pcb.html">tcp_pcb</a> for which to re-enqueue all unacked segments </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa90f8051c9633d3017c588245cdc4014"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa90f8051c9633d3017c588245cdc4014">&#9670;&nbsp;</a></span>tcp_rst()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tcp_rst </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *&#160;</td>
          <td class="paramname"><em>pcb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32_t&#160;</td>
          <td class="paramname"><em>seqno</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32_t&#160;</td>
          <td class="paramname"><em>ackno</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__ipaddr.html#ga16ef96d6cde029029bbf47fee35fd67a">ip_addr_t</a> *&#160;</td>
          <td class="paramname"><em>local_ip</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__ipaddr.html#ga16ef96d6cde029029bbf47fee35fd67a">ip_addr_t</a> *&#160;</td>
          <td class="paramname"><em>remote_ip</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u16_t&#160;</td>
          <td class="paramname"><em>local_port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u16_t&#160;</td>
          <td class="paramname"><em>remote_port</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Send a TCP RESET packet (empty segment with RST flag set) either to abort a connection or to show that there is no matching local connection for a received segment.</p>
<p>Called by <a class="el" href="group__tcp__raw.html#ga468c2260ddb01582e966ddcf3c25ce61">tcp_abort()</a> (to abort a local connection), <a class="el" href="tcp__in_8c.html#ae70c3c99d9dd6b07f7e11f7ba5eedcb5">tcp_input()</a> (if no matching local pcb was found), tcp_listen_input() (if incoming segment has ACK flag set) and tcp_process() (received segment in the wrong state)</p>
<p>Since a RST segment is in most cases not sent for an active connection, <a class="el" href="tcp__out_8c.html#aa90f8051c9633d3017c588245cdc4014">tcp_rst()</a> has a number of arguments that are taken from a <a class="el" href="structtcp__pcb.html">tcp_pcb</a> for most other segment output functions.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pcb</td><td>TCP pcb (may be NULL if no pcb is available) </td></tr>
    <tr><td class="paramname">seqno</td><td>the sequence number to use for the outgoing segment </td></tr>
    <tr><td class="paramname">ackno</td><td>the acknowledge number to use for the outgoing segment </td></tr>
    <tr><td class="paramname">local_ip</td><td>the local IP address to send the segment from </td></tr>
    <tr><td class="paramname">remote_ip</td><td>the remote IP address to send the segment to </td></tr>
    <tr><td class="paramname">local_port</td><td>the local TCP port to send the segment from </td></tr>
    <tr><td class="paramname">remote_port</td><td>the remote TCP port to send the segment to </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aefde3e34b2cc8df9654986484c44a996"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefde3e34b2cc8df9654986484c44a996">&#9670;&nbsp;</a></span>tcp_send_empty_ack()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__infrastructure__errors.html#gaf02d9da80fd66b4f986d2c53d7231ddb">err_t</a> tcp_send_empty_ack </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *&#160;</td>
          <td class="paramname"><em>pcb</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Send an ACK without data.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pcb</td><td>Protocol control block for the TCP connection to send the ACK </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af40ba9d645a8910436c3d7cf13dba342"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af40ba9d645a8910436c3d7cf13dba342">&#9670;&nbsp;</a></span>tcp_send_fin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__infrastructure__errors.html#gaf02d9da80fd66b4f986d2c53d7231ddb">err_t</a> tcp_send_fin </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *&#160;</td>
          <td class="paramname"><em>pcb</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Called by <a class="el" href="group__tcp__raw.html#ga87093e137fcc53ea82a134a3f5b33623">tcp_close()</a> to send a segment including FIN flag but not data. This FIN may be added to an existing segment or a new, otherwise empty segment is enqueued.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pcb</td><td>the <a class="el" href="structtcp__pcb.html">tcp_pcb</a> over which to send a segment </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ERR_OK if sent, another err_t otherwise </dd></dl>

</div>
</div>
<a id="ac930859c4e4ad9fcf6bb25ef5e91bcd5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac930859c4e4ad9fcf6bb25ef5e91bcd5">&#9670;&nbsp;</a></span>tcp_split_unsent_seg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__infrastructure__errors.html#gaf02d9da80fd66b4f986d2c53d7231ddb">err_t</a> tcp_split_unsent_seg </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *&#160;</td>
          <td class="paramname"><em>pcb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u16_t&#160;</td>
          <td class="paramname"><em>split</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Split segment on the head of the unsent queue. If return is not ERR_OK, existing head remains intact</p>
<p>The split is accomplished by creating a new TCP segment and pbuf which holds the remainder payload after the split. The original pbuf is trimmed to new length. This allows splitting of read-only pbufs</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pcb</td><td>the <a class="el" href="structtcp__pcb.html">tcp_pcb</a> for which to split the unsent head </td></tr>
    <tr><td class="paramname">split</td><td>the amount of payload to remain in the head </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6c20490aa45c771c38ce8ad3031cbdf6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c20490aa45c771c38ce8ad3031cbdf6">&#9670;&nbsp;</a></span>tcp_zero_window_probe()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__infrastructure__errors.html#gaf02d9da80fd66b4f986d2c53d7231ddb">err_t</a> tcp_zero_window_probe </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *&#160;</td>
          <td class="paramname"><em>pcb</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Send persist timer zero-window probes to keep a connection active when a window update is lost.</p>
<p>Called by <a class="el" href="tcp_8c.html#a421fb42ef919018e14ae413adfee9905">tcp_slowtmr()</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pcb</td><td>the <a class="el" href="structtcp__pcb.html">tcp_pcb</a> for which to send a zero-window probe packet </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_68267d1309a1af8e8297ef4c3efbcdba.html">src</a></li><li class="navelem"><a class="el" href="dir_aebb8dcc11953d78e620bbef0b9e2183.html">core</a></li><li class="navelem"><a class="el" href="tcp__out_8c.html">tcp_out.c</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
