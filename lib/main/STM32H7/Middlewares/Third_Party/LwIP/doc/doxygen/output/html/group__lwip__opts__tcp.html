<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>lwIP: TCP</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">lwIP
   &#160;<span id="projectnumber">2.1.2</span>
   </div>
   <div id="projectbrief">Lightweight IP stack</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__lwip__opts__tcp.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a>  </div>
  <div class="headertitle">
<div class="title">TCP<div class="ingroups"><a class="el" href="group__lwip.html">lwIP</a> &raquo; <a class="el" href="group__lwip__opts.html">Options (lwipopts.h)</a> &raquo; <a class="el" href="group__lwip__opts__callback.html">Callback-style APIs</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:gaa4ed98deb97b77c633cb8870f34c71e9"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lwip__opts__tcp.html#gaa4ed98deb97b77c633cb8870f34c71e9">LWIP_TCP</a>&#160;&#160;&#160;1</td></tr>
<tr class="separator:gaa4ed98deb97b77c633cb8870f34c71e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacd5b25ea81d2894790d25da5393cdab4"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lwip__opts__tcp.html#gacd5b25ea81d2894790d25da5393cdab4">TCP_TTL</a>&#160;&#160;&#160;<a class="el" href="group__lwip__opts__ipv4.html#ga556b9b58fd02c0fdd126791baef77411">IP_DEFAULT_TTL</a></td></tr>
<tr class="separator:gacd5b25ea81d2894790d25da5393cdab4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7f535a6efb5cdf86c3210e35ece1d6a7"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lwip__opts__tcp.html#ga7f535a6efb5cdf86c3210e35ece1d6a7">TCP_WND</a>&#160;&#160;&#160;(4 * <a class="el" href="group__lwip__opts__tcp.html#gaf1ab7bb27860aa3677c387a2f3ba317b">TCP_MSS</a>)</td></tr>
<tr class="separator:ga7f535a6efb5cdf86c3210e35ece1d6a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0dee0911197855bdf19ef79778c241a6"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lwip__opts__tcp.html#ga0dee0911197855bdf19ef79778c241a6">TCP_MAXRTX</a>&#160;&#160;&#160;12</td></tr>
<tr class="separator:ga0dee0911197855bdf19ef79778c241a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga50b434a8541a4813f7b27f576c05d1b6"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lwip__opts__tcp.html#ga50b434a8541a4813f7b27f576c05d1b6">TCP_SYNMAXRTX</a>&#160;&#160;&#160;6</td></tr>
<tr class="separator:ga50b434a8541a4813f7b27f576c05d1b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga89ffd0d7d1529bdb26bfbad267d0ad75"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lwip__opts__tcp.html#ga89ffd0d7d1529bdb26bfbad267d0ad75">TCP_QUEUE_OOSEQ</a>&#160;&#160;&#160;<a class="el" href="group__lwip__opts__tcp.html#gaa4ed98deb97b77c633cb8870f34c71e9">LWIP_TCP</a></td></tr>
<tr class="separator:ga89ffd0d7d1529bdb26bfbad267d0ad75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf1b6a015d29fea67b906c276e1e8314f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lwip__opts__tcp.html#gaf1b6a015d29fea67b906c276e1e8314f">LWIP_TCP_SACK_OUT</a>&#160;&#160;&#160;0</td></tr>
<tr class="separator:gaf1b6a015d29fea67b906c276e1e8314f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaac0e9f559a8e3c251f3504cebcf44dc"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lwip__opts__tcp.html#gaaac0e9f559a8e3c251f3504cebcf44dc">LWIP_TCP_MAX_SACK_NUM</a>&#160;&#160;&#160;4</td></tr>
<tr class="separator:gaaac0e9f559a8e3c251f3504cebcf44dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf1ab7bb27860aa3677c387a2f3ba317b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lwip__opts__tcp.html#gaf1ab7bb27860aa3677c387a2f3ba317b">TCP_MSS</a>&#160;&#160;&#160;536</td></tr>
<tr class="separator:gaf1ab7bb27860aa3677c387a2f3ba317b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac04b84d32251ac558f0c3a8af85ba3a5"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lwip__opts__tcp.html#gac04b84d32251ac558f0c3a8af85ba3a5">TCP_CALCULATE_EFF_SEND_MSS</a>&#160;&#160;&#160;1</td></tr>
<tr class="separator:gac04b84d32251ac558f0c3a8af85ba3a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga871d111968d8c6c7880ff36b93c5c4dd"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lwip__opts__tcp.html#ga871d111968d8c6c7880ff36b93c5c4dd">TCP_SND_BUF</a>&#160;&#160;&#160;(2 * <a class="el" href="group__lwip__opts__tcp.html#gaf1ab7bb27860aa3677c387a2f3ba317b">TCP_MSS</a>)</td></tr>
<tr class="separator:ga871d111968d8c6c7880ff36b93c5c4dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9beaa47832ead4180981bfbf71074904"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lwip__opts__tcp.html#ga9beaa47832ead4180981bfbf71074904">TCP_SND_QUEUELEN</a>&#160;&#160;&#160;((4 * (<a class="el" href="group__lwip__opts__tcp.html#ga871d111968d8c6c7880ff36b93c5c4dd">TCP_SND_BUF</a>) + (<a class="el" href="group__lwip__opts__tcp.html#gaf1ab7bb27860aa3677c387a2f3ba317b">TCP_MSS</a> - 1))/(<a class="el" href="group__lwip__opts__tcp.html#gaf1ab7bb27860aa3677c387a2f3ba317b">TCP_MSS</a>))</td></tr>
<tr class="separator:ga9beaa47832ead4180981bfbf71074904"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae5c9866d7cd463ac7b36792182145aec"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lwip__opts__tcp.html#gae5c9866d7cd463ac7b36792182145aec">TCP_SNDLOWAT</a>&#160;&#160;&#160;LWIP_MIN(LWIP_MAX(((<a class="el" href="group__lwip__opts__tcp.html#ga871d111968d8c6c7880ff36b93c5c4dd">TCP_SND_BUF</a>)/2), (2 * <a class="el" href="group__lwip__opts__tcp.html#gaf1ab7bb27860aa3677c387a2f3ba317b">TCP_MSS</a>) + 1), (<a class="el" href="group__lwip__opts__tcp.html#ga871d111968d8c6c7880ff36b93c5c4dd">TCP_SND_BUF</a>) - 1)</td></tr>
<tr class="separator:gae5c9866d7cd463ac7b36792182145aec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga75659867592a6b01c198532ed1b65698"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lwip__opts__tcp.html#ga75659867592a6b01c198532ed1b65698">TCP_SNDQUEUELOWAT</a>&#160;&#160;&#160;LWIP_MAX(((<a class="el" href="group__lwip__opts__tcp.html#ga9beaa47832ead4180981bfbf71074904">TCP_SND_QUEUELEN</a>)/2), 5)</td></tr>
<tr class="separator:ga75659867592a6b01c198532ed1b65698"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9d6d3219bb5fc0bc760a64114de13c25"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lwip__opts__tcp.html#ga9d6d3219bb5fc0bc760a64114de13c25">TCP_OOSEQ_MAX_BYTES</a>&#160;&#160;&#160;0</td></tr>
<tr class="separator:ga9d6d3219bb5fc0bc760a64114de13c25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1f57d3859c4556f785708e5dc440617e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lwip__opts__tcp.html#ga1f57d3859c4556f785708e5dc440617e">TCP_OOSEQ_MAX_PBUFS</a>&#160;&#160;&#160;0</td></tr>
<tr class="separator:ga1f57d3859c4556f785708e5dc440617e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga98b23e7cbd3281915c50a485cb61899d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lwip__opts__tcp.html#ga98b23e7cbd3281915c50a485cb61899d">TCP_LISTEN_BACKLOG</a>&#160;&#160;&#160;0</td></tr>
<tr class="separator:ga98b23e7cbd3281915c50a485cb61899d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga93cce3f47e33df11248c908d1775bacf"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lwip__opts__tcp.html#ga93cce3f47e33df11248c908d1775bacf">TCP_DEFAULT_LISTEN_BACKLOG</a>&#160;&#160;&#160;0xff</td></tr>
<tr class="separator:ga93cce3f47e33df11248c908d1775bacf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5648e2580bb55c0efdfbebcf3bad1eef"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lwip__opts__tcp.html#ga5648e2580bb55c0efdfbebcf3bad1eef">TCP_OVERSIZE</a>&#160;&#160;&#160;<a class="el" href="group__lwip__opts__tcp.html#gaf1ab7bb27860aa3677c387a2f3ba317b">TCP_MSS</a></td></tr>
<tr class="separator:ga5648e2580bb55c0efdfbebcf3bad1eef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga249bc450bb818cf2ef3cf1472ff354fd"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lwip__opts__tcp.html#ga249bc450bb818cf2ef3cf1472ff354fd">LWIP_TCP_TIMESTAMPS</a>&#160;&#160;&#160;0</td></tr>
<tr class="separator:ga249bc450bb818cf2ef3cf1472ff354fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5d45732ba3a8438b141096d86e07ef8d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lwip__opts__tcp.html#ga5d45732ba3a8438b141096d86e07ef8d">TCP_WND_UPDATE_THRESHOLD</a>&#160;&#160;&#160;LWIP_MIN((<a class="el" href="group__lwip__opts__tcp.html#ga7f535a6efb5cdf86c3210e35ece1d6a7">TCP_WND</a> / 4), (<a class="el" href="group__lwip__opts__tcp.html#gaf1ab7bb27860aa3677c387a2f3ba317b">TCP_MSS</a> * 4))</td></tr>
<tr class="separator:ga5d45732ba3a8438b141096d86e07ef8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga39f76e811117155be8525bb386ecddb7"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lwip__opts__tcp.html#ga39f76e811117155be8525bb386ecddb7">LWIP_EVENT_API</a>&#160;&#160;&#160;0</td></tr>
<tr class="separator:ga39f76e811117155be8525bb386ecddb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga88dbbfeeeb41b129fdc8235fc08bb530"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lwip__opts__tcp.html#ga88dbbfeeeb41b129fdc8235fc08bb530">LWIP_WND_SCALE</a>&#160;&#160;&#160;0</td></tr>
<tr class="separator:ga88dbbfeeeb41b129fdc8235fc08bb530"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga40b1cdad52eaa91a3f5c242fc92ee223"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lwip__opts__tcp.html#ga40b1cdad52eaa91a3f5c242fc92ee223">LWIP_TCP_PCB_NUM_EXT_ARGS</a>&#160;&#160;&#160;0</td></tr>
<tr class="separator:ga40b1cdad52eaa91a3f5c242fc92ee223"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga26dee0e5d9c51b1dda0adad29c770a77"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lwip__opts__tcp.html#ga26dee0e5d9c51b1dda0adad29c770a77">LWIP_ALTCP</a>&#160;&#160;&#160;0</td></tr>
<tr class="separator:ga26dee0e5d9c51b1dda0adad29c770a77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab03ba0306cf0a99ccce3d100142f60c8"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lwip__opts__tcp.html#gab03ba0306cf0a99ccce3d100142f60c8">LWIP_ALTCP_TLS</a>&#160;&#160;&#160;0</td></tr>
<tr class="separator:gab03ba0306cf0a99ccce3d100142f60c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ga26dee0e5d9c51b1dda0adad29c770a77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga26dee0e5d9c51b1dda0adad29c770a77">&#9670;&nbsp;</a></span>LWIP_ALTCP</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LWIP_ALTCP&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>LWIP_ALTCP==1: enable the altcp API. altcp is an abstraction layer that prevents applications linking against the tcp.h functions but provides the same functionality. It is used to e.g. add SSL/TLS or proxy-connect support to an application written for the tcp callback API without that application knowing the protocol details.</p>
<p>With LWIP_ALTCP==0, applications written against the altcp API can still be compiled but are directly linked against the tcp.h callback API and then cannot use layered protocols.</p>
<p>See <a class="el" href="group__altcp__api.html">Application layered TCP Introduction</a> </p>

</div>
</div>
<a id="gab03ba0306cf0a99ccce3d100142f60c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab03ba0306cf0a99ccce3d100142f60c8">&#9670;&nbsp;</a></span>LWIP_ALTCP_TLS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LWIP_ALTCP_TLS&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>LWIP_ALTCP_TLS==1: enable TLS support for altcp API. This needs a port of the functions in <a class="el" href="altcp__tls_8h.html">altcp_tls.h</a> to a TLS library. A port to ARM mbedtls is provided with lwIP, see apps/altcp_tls/ directory and LWIP_ALTCP_TLS_MBEDTLS option. </p>

</div>
</div>
<a id="ga39f76e811117155be8525bb386ecddb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga39f76e811117155be8525bb386ecddb7">&#9670;&nbsp;</a></span>LWIP_EVENT_API</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LWIP_EVENT_API&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>LWIP_EVENT_API and LWIP_CALLBACK_API: Only one of these should be set to 1. LWIP_EVENT_API==1: The user defines lwip_tcp_event() to receive all events (accept, sent, etc) that happen in the system. LWIP_CALLBACK_API==1: The PCB callback function is called directly for the event. This is the default. </p>

</div>
</div>
<a id="gaa4ed98deb97b77c633cb8870f34c71e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa4ed98deb97b77c633cb8870f34c71e9">&#9670;&nbsp;</a></span>LWIP_TCP</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LWIP_TCP&#160;&#160;&#160;1</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>LWIP_TCP==1: Turn on TCP. </p>

</div>
</div>
<a id="gaaac0e9f559a8e3c251f3504cebcf44dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaac0e9f559a8e3c251f3504cebcf44dc">&#9670;&nbsp;</a></span>LWIP_TCP_MAX_SACK_NUM</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LWIP_TCP_MAX_SACK_NUM&#160;&#160;&#160;4</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>LWIP_TCP_MAX_SACK_NUM: The maximum number of SACK values to include in TCP segments. Must be at least 1, but is only used if LWIP_TCP_SACK_OUT is enabled. NOTE: Even though we never send more than 3 or 4 SACK ranges in a single segment (depending on other options), setting this option to values greater than 4 is not pointless. This is basically the max number of SACK ranges we want to keep track of. As new data is delivered, some of the SACK ranges may be removed or merged. In that case some of those older SACK ranges may be used again. The amount of memory used to store SACK ranges is LWIP_TCP_MAX_SACK_NUM * 8 bytes for each TCP PCB. </p>

</div>
</div>
<a id="ga40b1cdad52eaa91a3f5c242fc92ee223"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga40b1cdad52eaa91a3f5c242fc92ee223">&#9670;&nbsp;</a></span>LWIP_TCP_PCB_NUM_EXT_ARGS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LWIP_TCP_PCB_NUM_EXT_ARGS&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>LWIP_TCP_PCB_NUM_EXT_ARGS: When this is &gt; 0, every tcp pcb (including listen pcb) includes a number of additional argument entries in an array (see tcp_ext_arg_alloc_id) </p>

</div>
</div>
<a id="gaf1b6a015d29fea67b906c276e1e8314f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf1b6a015d29fea67b906c276e1e8314f">&#9670;&nbsp;</a></span>LWIP_TCP_SACK_OUT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LWIP_TCP_SACK_OUT&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>LWIP_TCP_SACK_OUT==1: TCP will support sending selective acknowledgements (SACKs). </p>

</div>
</div>
<a id="ga249bc450bb818cf2ef3cf1472ff354fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga249bc450bb818cf2ef3cf1472ff354fd">&#9670;&nbsp;</a></span>LWIP_TCP_TIMESTAMPS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LWIP_TCP_TIMESTAMPS&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>LWIP_TCP_TIMESTAMPS==1: support the TCP timestamp option. The timestamp option is currently only used to help remote hosts, it is not really used locally. Therefore, it is only enabled when a TS option is received in the initial SYN packet from a remote host. </p>

</div>
</div>
<a id="ga88dbbfeeeb41b129fdc8235fc08bb530"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga88dbbfeeeb41b129fdc8235fc08bb530">&#9670;&nbsp;</a></span>LWIP_WND_SCALE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LWIP_WND_SCALE&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>LWIP_WND_SCALE and TCP_RCV_SCALE: Set LWIP_WND_SCALE to 1 to enable window scaling. Set TCP_RCV_SCALE to the desired scaling factor (shift count in the range of [0..14]). When LWIP_WND_SCALE is enabled but TCP_RCV_SCALE is 0, we can use a large send window while having a small receive window only. </p>

</div>
</div>
<a id="gac04b84d32251ac558f0c3a8af85ba3a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac04b84d32251ac558f0c3a8af85ba3a5">&#9670;&nbsp;</a></span>TCP_CALCULATE_EFF_SEND_MSS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define TCP_CALCULATE_EFF_SEND_MSS&#160;&#160;&#160;1</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>TCP_CALCULATE_EFF_SEND_MSS: "The maximum size of a segment that TCP really sends, the 'effective send MSS,' MUST be the smaller of the send MSS (which reflects the available reassembly buffer size at the remote host) and the largest size permitted by the IP layer" (RFC 1122) Setting this to 1 enables code that checks TCP_MSS against the MTU of the netif used for a connection and limits the MSS if it would be too big otherwise. </p>

</div>
</div>
<a id="ga93cce3f47e33df11248c908d1775bacf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga93cce3f47e33df11248c908d1775bacf">&#9670;&nbsp;</a></span>TCP_DEFAULT_LISTEN_BACKLOG</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define TCP_DEFAULT_LISTEN_BACKLOG&#160;&#160;&#160;0xff</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The maximum allowed backlog for TCP listen netconns. This backlog is used unless another is explicitly specified. 0xff is the maximum (u8_t). </p>

</div>
</div>
<a id="ga98b23e7cbd3281915c50a485cb61899d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga98b23e7cbd3281915c50a485cb61899d">&#9670;&nbsp;</a></span>TCP_LISTEN_BACKLOG</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define TCP_LISTEN_BACKLOG&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>TCP_OOSEQ_PBUFS_LIMIT(pcb): Return the maximum number of pbufs to be queued on ooseq per pcb, given the pcb. Only valid for TCP_QUEUE_OOSEQ==1 &amp;&amp; TCP_OOSEQ_MAX_PBUFS==1. Use this to override TCP_OOSEQ_MAX_PBUFS to a dynamic value per pcb. TCP_LISTEN_BACKLOG: Enable the backlog option for tcp listen pcb. </p>

</div>
</div>
<a id="ga0dee0911197855bdf19ef79778c241a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0dee0911197855bdf19ef79778c241a6">&#9670;&nbsp;</a></span>TCP_MAXRTX</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define TCP_MAXRTX&#160;&#160;&#160;12</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>TCP_MAXRTX: Maximum number of retransmissions of data segments. </p>

</div>
</div>
<a id="gaf1ab7bb27860aa3677c387a2f3ba317b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf1ab7bb27860aa3677c387a2f3ba317b">&#9670;&nbsp;</a></span>TCP_MSS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define TCP_MSS&#160;&#160;&#160;536</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>TCP_MSS: TCP Maximum segment size. (default is 536, a conservative default, you might want to increase this.) For the receive side, this MSS is advertised to the remote side when opening a connection. For the transmit size, this MSS sets an upper limit on the MSS advertised by the remote host. </p>

</div>
</div>
<a id="ga9d6d3219bb5fc0bc760a64114de13c25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9d6d3219bb5fc0bc760a64114de13c25">&#9670;&nbsp;</a></span>TCP_OOSEQ_MAX_BYTES</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define TCP_OOSEQ_MAX_BYTES&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>TCP_OOSEQ_MAX_BYTES: The default maximum number of bytes queued on ooseq per pcb if TCP_OOSEQ_BYTES_LIMIT is not defined. Default is 0 (no limit). Only valid for TCP_QUEUE_OOSEQ==1. </p>

</div>
</div>
<a id="ga1f57d3859c4556f785708e5dc440617e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1f57d3859c4556f785708e5dc440617e">&#9670;&nbsp;</a></span>TCP_OOSEQ_MAX_PBUFS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define TCP_OOSEQ_MAX_PBUFS&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>TCP_OOSEQ_BYTES_LIMIT(pcb): Return the maximum number of bytes to be queued on ooseq per pcb, given the pcb. Only valid for TCP_QUEUE_OOSEQ==1 &amp;&amp; TCP_OOSEQ_MAX_BYTES==1. Use this to override TCP_OOSEQ_MAX_BYTES to a dynamic value per pcb. TCP_OOSEQ_MAX_PBUFS: The default maximum number of pbufs queued on ooseq per pcb if TCP_OOSEQ_BYTES_LIMIT is not defined. Default is 0 (no limit). Only valid for TCP_QUEUE_OOSEQ==1. </p>

</div>
</div>
<a id="ga5648e2580bb55c0efdfbebcf3bad1eef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5648e2580bb55c0efdfbebcf3bad1eef">&#9670;&nbsp;</a></span>TCP_OVERSIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define TCP_OVERSIZE&#160;&#160;&#160;<a class="el" href="group__lwip__opts__tcp.html#gaf1ab7bb27860aa3677c387a2f3ba317b">TCP_MSS</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>TCP_OVERSIZE: The maximum number of bytes that tcp_write may allocate ahead of time in an attempt to create shorter pbuf chains for transmission. The meaningful range is 0 to TCP_MSS. Some suggested values are:</p>
<p>0: Disable oversized allocation. Each <a class="el" href="group__tcp__raw.html#ga6b2aa0efbf10e254930332b7c89cd8c5">tcp_write()</a> allocates a new pbuf (old behaviour). 1: Allocate size-aligned pbufs with minimal excess. Use this if your scatter-gather DMA requires aligned fragments. 128: Limit the pbuf/memory overhead to 20%. TCP_MSS: Try to create unfragmented TCP packets. TCP_MSS/4: Try to create 4 fragments or less per TCP packet. </p>

</div>
</div>
<a id="ga89ffd0d7d1529bdb26bfbad267d0ad75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga89ffd0d7d1529bdb26bfbad267d0ad75">&#9670;&nbsp;</a></span>TCP_QUEUE_OOSEQ</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define TCP_QUEUE_OOSEQ&#160;&#160;&#160;<a class="el" href="group__lwip__opts__tcp.html#gaa4ed98deb97b77c633cb8870f34c71e9">LWIP_TCP</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>TCP_QUEUE_OOSEQ==1: TCP will queue segments that arrive out of order. Define to 0 if your device is low on memory. </p>

</div>
</div>
<a id="ga871d111968d8c6c7880ff36b93c5c4dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga871d111968d8c6c7880ff36b93c5c4dd">&#9670;&nbsp;</a></span>TCP_SND_BUF</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define TCP_SND_BUF&#160;&#160;&#160;(2 * <a class="el" href="group__lwip__opts__tcp.html#gaf1ab7bb27860aa3677c387a2f3ba317b">TCP_MSS</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>TCP_SND_BUF: TCP sender buffer space (bytes). To achieve good performance, this should be at least 2 * TCP_MSS. </p>

</div>
</div>
<a id="ga9beaa47832ead4180981bfbf71074904"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9beaa47832ead4180981bfbf71074904">&#9670;&nbsp;</a></span>TCP_SND_QUEUELEN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define TCP_SND_QUEUELEN&#160;&#160;&#160;((4 * (<a class="el" href="group__lwip__opts__tcp.html#ga871d111968d8c6c7880ff36b93c5c4dd">TCP_SND_BUF</a>) + (<a class="el" href="group__lwip__opts__tcp.html#gaf1ab7bb27860aa3677c387a2f3ba317b">TCP_MSS</a> - 1))/(<a class="el" href="group__lwip__opts__tcp.html#gaf1ab7bb27860aa3677c387a2f3ba317b">TCP_MSS</a>))</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>TCP_SND_QUEUELEN: TCP sender buffer space (pbufs). This must be at least as much as (2 * TCP_SND_BUF/TCP_MSS) for things to work. </p>

</div>
</div>
<a id="gae5c9866d7cd463ac7b36792182145aec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae5c9866d7cd463ac7b36792182145aec">&#9670;&nbsp;</a></span>TCP_SNDLOWAT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define TCP_SNDLOWAT&#160;&#160;&#160;LWIP_MIN(LWIP_MAX(((<a class="el" href="group__lwip__opts__tcp.html#ga871d111968d8c6c7880ff36b93c5c4dd">TCP_SND_BUF</a>)/2), (2 * <a class="el" href="group__lwip__opts__tcp.html#gaf1ab7bb27860aa3677c387a2f3ba317b">TCP_MSS</a>) + 1), (<a class="el" href="group__lwip__opts__tcp.html#ga871d111968d8c6c7880ff36b93c5c4dd">TCP_SND_BUF</a>) - 1)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>TCP_SNDLOWAT: TCP writable space (bytes). This must be less than TCP_SND_BUF. It is the amount of space which must be available in the TCP snd_buf for select to return writable (combined with TCP_SNDQUEUELOWAT). </p>

</div>
</div>
<a id="ga75659867592a6b01c198532ed1b65698"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga75659867592a6b01c198532ed1b65698">&#9670;&nbsp;</a></span>TCP_SNDQUEUELOWAT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define TCP_SNDQUEUELOWAT&#160;&#160;&#160;LWIP_MAX(((<a class="el" href="group__lwip__opts__tcp.html#ga9beaa47832ead4180981bfbf71074904">TCP_SND_QUEUELEN</a>)/2), 5)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>TCP_SNDQUEUELOWAT: TCP writable bufs (pbuf count). This must be less than TCP_SND_QUEUELEN. If the number of pbufs queued on a pcb drops below this number, select returns writable (combined with TCP_SNDLOWAT). </p>

</div>
</div>
<a id="ga50b434a8541a4813f7b27f576c05d1b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga50b434a8541a4813f7b27f576c05d1b6">&#9670;&nbsp;</a></span>TCP_SYNMAXRTX</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define TCP_SYNMAXRTX&#160;&#160;&#160;6</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>TCP_SYNMAXRTX: Maximum number of retransmissions of SYN segments. </p>

</div>
</div>
<a id="gacd5b25ea81d2894790d25da5393cdab4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacd5b25ea81d2894790d25da5393cdab4">&#9670;&nbsp;</a></span>TCP_TTL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define TCP_TTL&#160;&#160;&#160;<a class="el" href="group__lwip__opts__ipv4.html#ga556b9b58fd02c0fdd126791baef77411">IP_DEFAULT_TTL</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>TCP_TTL: Default Time-To-Live value. </p>

</div>
</div>
<a id="ga7f535a6efb5cdf86c3210e35ece1d6a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7f535a6efb5cdf86c3210e35ece1d6a7">&#9670;&nbsp;</a></span>TCP_WND</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define TCP_WND&#160;&#160;&#160;(4 * <a class="el" href="group__lwip__opts__tcp.html#gaf1ab7bb27860aa3677c387a2f3ba317b">TCP_MSS</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>TCP_WND: The size of a TCP window. This must be at least (2 * TCP_MSS) for things to work well. ATTENTION: when using TCP_RCV_SCALE, TCP_WND is the total size with scaling applied. Maximum window value in the TCP header will be TCP_WND &gt;&gt; TCP_RCV_SCALE </p>

</div>
</div>
<a id="ga5d45732ba3a8438b141096d86e07ef8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5d45732ba3a8438b141096d86e07ef8d">&#9670;&nbsp;</a></span>TCP_WND_UPDATE_THRESHOLD</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define TCP_WND_UPDATE_THRESHOLD&#160;&#160;&#160;LWIP_MIN((<a class="el" href="group__lwip__opts__tcp.html#ga7f535a6efb5cdf86c3210e35ece1d6a7">TCP_WND</a> / 4), (<a class="el" href="group__lwip__opts__tcp.html#gaf1ab7bb27860aa3677c387a2f3ba317b">TCP_MSS</a> * 4))</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>TCP_WND_UPDATE_THRESHOLD: difference in window to trigger an explicit window update </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
