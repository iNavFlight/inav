<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>lwIP: UDP</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">lwIP
   &#160;<span id="projectnumber">2.1.2</span>
   </div>
   <div id="projectbrief">Lightweight IP stack</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__udp__raw.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">UDP<div class="ingroups"><a class="el" href="group__api.html">APIs</a> &raquo; <a class="el" href="group__callbackstyle__api.html">&quot;raw&quot; APIs</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gaa4546c43981f043c0ae4514d625cc3fc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__infrastructure__errors.html#gaf02d9da80fd66b4f986d2c53d7231ddb">err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udp__raw.html#gaa4546c43981f043c0ae4514d625cc3fc">udp_send</a> (struct <a class="el" href="structudp__pcb.html">udp_pcb</a> *pcb, struct <a class="el" href="structpbuf.html">pbuf</a> *p)</td></tr>
<tr class="separator:gaa4546c43981f043c0ae4514d625cc3fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa0e135a5958f1f0cc83cbeb609e18743"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__infrastructure__errors.html#gaf02d9da80fd66b4f986d2c53d7231ddb">err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udp__raw.html#gaa0e135a5958f1f0cc83cbeb609e18743">udp_sendto</a> (struct <a class="el" href="structudp__pcb.html">udp_pcb</a> *pcb, struct <a class="el" href="structpbuf.html">pbuf</a> *p, const <a class="el" href="group__ipaddr.html#ga16ef96d6cde029029bbf47fee35fd67a">ip_addr_t</a> *dst_ip, u16_t dst_port)</td></tr>
<tr class="separator:gaa0e135a5958f1f0cc83cbeb609e18743"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga83f8c873671ca7f307d14b29a0a7a142"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__infrastructure__errors.html#gaf02d9da80fd66b4f986d2c53d7231ddb">err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udp__raw.html#ga83f8c873671ca7f307d14b29a0a7a142">udp_sendto_if</a> (struct <a class="el" href="structudp__pcb.html">udp_pcb</a> *pcb, struct <a class="el" href="structpbuf.html">pbuf</a> *p, const <a class="el" href="group__ipaddr.html#ga16ef96d6cde029029bbf47fee35fd67a">ip_addr_t</a> *dst_ip, u16_t dst_port, struct <a class="el" href="structnetif.html">netif</a> *<a class="el" href="structnetif.html">netif</a>)</td></tr>
<tr class="separator:ga83f8c873671ca7f307d14b29a0a7a142"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa389827c979c766c1dae301239f7bbb7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__infrastructure__errors.html#gaf02d9da80fd66b4f986d2c53d7231ddb">err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udp__raw.html#gaa389827c979c766c1dae301239f7bbb7">udp_sendto_if_src</a> (struct <a class="el" href="structudp__pcb.html">udp_pcb</a> *pcb, struct <a class="el" href="structpbuf.html">pbuf</a> *p, const <a class="el" href="group__ipaddr.html#ga16ef96d6cde029029bbf47fee35fd67a">ip_addr_t</a> *dst_ip, u16_t dst_port, struct <a class="el" href="structnetif.html">netif</a> *<a class="el" href="structnetif.html">netif</a>, const <a class="el" href="group__ipaddr.html#ga16ef96d6cde029029bbf47fee35fd67a">ip_addr_t</a> *src_ip)</td></tr>
<tr class="separator:gaa389827c979c766c1dae301239f7bbb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac7fbda8b12b9b9360e92b51e805e799e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__infrastructure__errors.html#gaf02d9da80fd66b4f986d2c53d7231ddb">err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udp__raw.html#gac7fbda8b12b9b9360e92b51e805e799e">udp_bind</a> (struct <a class="el" href="structudp__pcb.html">udp_pcb</a> *pcb, const <a class="el" href="group__ipaddr.html#ga16ef96d6cde029029bbf47fee35fd67a">ip_addr_t</a> *ipaddr, u16_t port)</td></tr>
<tr class="separator:gac7fbda8b12b9b9360e92b51e805e799e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4360535ae72e77019721c9637a1051a8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udp__raw.html#ga4360535ae72e77019721c9637a1051a8">udp_bind_netif</a> (struct <a class="el" href="structudp__pcb.html">udp_pcb</a> *pcb, const struct <a class="el" href="structnetif.html">netif</a> *<a class="el" href="structnetif.html">netif</a>)</td></tr>
<tr class="separator:ga4360535ae72e77019721c9637a1051a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga83625967670477aa254643129a53971b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__infrastructure__errors.html#gaf02d9da80fd66b4f986d2c53d7231ddb">err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udp__raw.html#ga83625967670477aa254643129a53971b">udp_connect</a> (struct <a class="el" href="structudp__pcb.html">udp_pcb</a> *pcb, const <a class="el" href="group__ipaddr.html#ga16ef96d6cde029029bbf47fee35fd67a">ip_addr_t</a> *ipaddr, u16_t port)</td></tr>
<tr class="separator:ga83625967670477aa254643129a53971b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8d26559743e59e4b409c92a268ee67fc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udp__raw.html#ga8d26559743e59e4b409c92a268ee67fc">udp_disconnect</a> (struct <a class="el" href="structudp__pcb.html">udp_pcb</a> *pcb)</td></tr>
<tr class="separator:ga8d26559743e59e4b409c92a268ee67fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gada6d02b9a5f35e1fb2e1bc71b11e6027"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udp__raw.html#gada6d02b9a5f35e1fb2e1bc71b11e6027">udp_recv</a> (struct <a class="el" href="structudp__pcb.html">udp_pcb</a> *pcb, <a class="el" href="udp_8h.html#af0ec7feb31acdb6e11b928f438c8a64b">udp_recv_fn</a> <a class="el" href="group__socket.html#gadd7ae45df7c005619eb1126542231e9b">recv</a>, void *recv_arg)</td></tr>
<tr class="separator:gada6d02b9a5f35e1fb2e1bc71b11e6027"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3aed8e469f74f960837ebf9f34acf646"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udp__raw.html#ga3aed8e469f74f960837ebf9f34acf646">udp_remove</a> (struct <a class="el" href="structudp__pcb.html">udp_pcb</a> *pcb)</td></tr>
<tr class="separator:ga3aed8e469f74f960837ebf9f34acf646"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa6d6430499acae43d342f0e68ddbb209"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structudp__pcb.html">udp_pcb</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udp__raw.html#gaa6d6430499acae43d342f0e68ddbb209">udp_new</a> (void)</td></tr>
<tr class="separator:gaa6d6430499acae43d342f0e68ddbb209"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf1ab236050dd351e93f112cfbc1ada88"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structudp__pcb.html">udp_pcb</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udp__raw.html#gaf1ab236050dd351e93f112cfbc1ada88">udp_new_ip_type</a> (u8_t type)</td></tr>
<tr class="separator:gaf1ab236050dd351e93f112cfbc1ada88"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>User Datagram Protocol module<br />
</p><dl class="section see"><dt>See also</dt><dd><a class="el" href="group__api.html">APIs</a> </dd></dl>
<h2 class="groupheader">Function Documentation</h2>
<a id="gac7fbda8b12b9b9360e92b51e805e799e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac7fbda8b12b9b9360e92b51e805e799e">&#9670;&nbsp;</a></span>udp_bind()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__infrastructure__errors.html#gaf02d9da80fd66b4f986d2c53d7231ddb">err_t</a> udp_bind </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structudp__pcb.html">udp_pcb</a> *&#160;</td>
          <td class="paramname"><em>pcb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__ipaddr.html#ga16ef96d6cde029029bbf47fee35fd67a">ip_addr_t</a> *&#160;</td>
          <td class="paramname"><em>ipaddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u16_t&#160;</td>
          <td class="paramname"><em>port</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Bind an UDP PCB.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pcb</td><td>UDP PCB to be bound with a local address ipaddr and port. </td></tr>
    <tr><td class="paramname">ipaddr</td><td>local IP address to bind with. Use IP_ANY_TYPE to bind to all local interfaces. </td></tr>
    <tr><td class="paramname">port</td><td>local UDP port to bind with. Use 0 to automatically bind to a random port between UDP_LOCAL_PORT_RANGE_START and UDP_LOCAL_PORT_RANGE_END.</td></tr>
  </table>
  </dd>
</dl>
<p>ipaddr &amp; port are expected to be in the same byte order as in the pcb.</p>
<dl class="section return"><dt>Returns</dt><dd>lwIP error code.<ul>
<li>ERR_OK. Successful. No error occurred.</li>
<li>ERR_USE. The specified ipaddr and port are already bound to by another UDP PCB.</li>
</ul>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__udp__raw.html#ga8d26559743e59e4b409c92a268ee67fc">udp_disconnect()</a> </dd></dl>

</div>
</div>
<a id="ga4360535ae72e77019721c9637a1051a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4360535ae72e77019721c9637a1051a8">&#9670;&nbsp;</a></span>udp_bind_netif()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void udp_bind_netif </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structudp__pcb.html">udp_pcb</a> *&#160;</td>
          <td class="paramname"><em>pcb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structnetif.html">netif</a> *&#160;</td>
          <td class="paramname"><em>netif</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Bind an UDP PCB to a specific netif. After calling this function, all packets received via this PCB are guaranteed to have come in via the specified netif, and all outgoing packets will go out via the specified netif.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pcb</td><td>UDP PCB to be bound. </td></tr>
    <tr><td class="paramname">netif</td><td>netif to bind udp pcb to. Can be NULL.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__udp__raw.html#ga8d26559743e59e4b409c92a268ee67fc">udp_disconnect()</a> </dd></dl>

</div>
</div>
<a id="ga83625967670477aa254643129a53971b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga83625967670477aa254643129a53971b">&#9670;&nbsp;</a></span>udp_connect()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__infrastructure__errors.html#gaf02d9da80fd66b4f986d2c53d7231ddb">err_t</a> udp_connect </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structudp__pcb.html">udp_pcb</a> *&#160;</td>
          <td class="paramname"><em>pcb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__ipaddr.html#ga16ef96d6cde029029bbf47fee35fd67a">ip_addr_t</a> *&#160;</td>
          <td class="paramname"><em>ipaddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u16_t&#160;</td>
          <td class="paramname"><em>port</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the remote end of the pcb. This function does not generate any network traffic, but only sets the remote address of the pcb.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pcb</td><td>UDP PCB to be connected with remote address ipaddr and port. </td></tr>
    <tr><td class="paramname">ipaddr</td><td>remote IP address to connect with. </td></tr>
    <tr><td class="paramname">port</td><td>remote UDP port to connect with.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>lwIP error code</dd></dl>
<p>ipaddr &amp; port are expected to be in the same byte order as in the pcb.</p>
<p>The udp pcb is bound to a random local port if not already bound.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__udp__raw.html#ga8d26559743e59e4b409c92a268ee67fc">udp_disconnect()</a> </dd></dl>

</div>
</div>
<a id="ga8d26559743e59e4b409c92a268ee67fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8d26559743e59e4b409c92a268ee67fc">&#9670;&nbsp;</a></span>udp_disconnect()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void udp_disconnect </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structudp__pcb.html">udp_pcb</a> *&#160;</td>
          <td class="paramname"><em>pcb</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Remove the remote end of the pcb. This function does not generate any network traffic, but only removes the remote address of the pcb.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pcb</td><td>the udp pcb to disconnect. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaa6d6430499acae43d342f0e68ddbb209"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa6d6430499acae43d342f0e68ddbb209">&#9670;&nbsp;</a></span>udp_new()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structudp__pcb.html">udp_pcb</a>* udp_new </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates a new UDP pcb which can be used for UDP communication. The pcb is not active until it has either been bound to a local address or connected to a remote address.</p>
<dl class="section return"><dt>Returns</dt><dd>The UDP PCB which was created. NULL if the PCB data structure could not be allocated.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__udp__raw.html#ga3aed8e469f74f960837ebf9f34acf646">udp_remove()</a> </dd></dl>

</div>
</div>
<a id="gaf1ab236050dd351e93f112cfbc1ada88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf1ab236050dd351e93f112cfbc1ada88">&#9670;&nbsp;</a></span>udp_new_ip_type()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structudp__pcb.html">udp_pcb</a>* udp_new_ip_type </td>
          <td>(</td>
          <td class="paramtype">u8_t&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a UDP PCB for specific IP type. The pcb is not active until it has either been bound to a local address or connected to a remote address.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>IP address type, see <a class="el" href="group__ipaddr.html#gaf2142f0dfdcc938e2db16aa745ed585c">lwip_ip_addr_type</a> definitions. If you want to listen to IPv4 and IPv6 (dual-stack) packets, supply <a class="el" href="group__ipaddr.html#ggaf2142f0dfdcc938e2db16aa745ed585cac6b2c99cf920e08efcb55dc40e42944e">IPADDR_TYPE_ANY</a> as argument and bind to <a class="el" href="group__ipaddr.html#gabe43b154533b73585c4e58f568370ede">IP_ANY_TYPE</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The UDP PCB which was created. NULL if the PCB data structure could not be allocated.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__udp__raw.html#ga3aed8e469f74f960837ebf9f34acf646">udp_remove()</a> </dd></dl>

</div>
</div>
<a id="gada6d02b9a5f35e1fb2e1bc71b11e6027"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gada6d02b9a5f35e1fb2e1bc71b11e6027">&#9670;&nbsp;</a></span>udp_recv()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void udp_recv </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structudp__pcb.html">udp_pcb</a> *&#160;</td>
          <td class="paramname"><em>pcb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="udp_8h.html#af0ec7feb31acdb6e11b928f438c8a64b">udp_recv_fn</a>&#160;</td>
          <td class="paramname"><em>recv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>recv_arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set a receive callback for a UDP PCB. This callback will be called when receiving a datagram for the pcb.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pcb</td><td>the pcb for which to set the recv callback </td></tr>
    <tr><td class="paramname">recv</td><td>function pointer of the callback function </td></tr>
    <tr><td class="paramname">recv_arg</td><td>additional argument to pass to the callback function </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga3aed8e469f74f960837ebf9f34acf646"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3aed8e469f74f960837ebf9f34acf646">&#9670;&nbsp;</a></span>udp_remove()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void udp_remove </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structudp__pcb.html">udp_pcb</a> *&#160;</td>
          <td class="paramname"><em>pcb</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Removes and deallocates the pcb.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pcb</td><td>UDP PCB to be removed. The PCB is removed from the list of UDP PCB's and the data structure is freed from memory.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__udp__raw.html#gaa6d6430499acae43d342f0e68ddbb209">udp_new()</a> </dd></dl>

</div>
</div>
<a id="gaa4546c43981f043c0ae4514d625cc3fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa4546c43981f043c0ae4514d625cc3fc">&#9670;&nbsp;</a></span>udp_send()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__infrastructure__errors.html#gaf02d9da80fd66b4f986d2c53d7231ddb">err_t</a> udp_send </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structudp__pcb.html">udp_pcb</a> *&#160;</td>
          <td class="paramname"><em>pcb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structpbuf.html">pbuf</a> *&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sends the pbuf p using UDP. The pbuf is not deallocated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pcb</td><td>UDP PCB used to send the data. </td></tr>
    <tr><td class="paramname">p</td><td>chain of pbuf's to be sent.</td></tr>
  </table>
  </dd>
</dl>
<p>The datagram will be sent to the current remote_ip &amp; remote_port stored in pcb. If the pcb is not bound to a port, it will automatically be bound to a random port.</p>
<dl class="section return"><dt>Returns</dt><dd>lwIP error code.<ul>
<li>ERR_OK. Successful. No error occurred.</li>
<li>ERR_MEM. Out of memory.</li>
<li>ERR_RTE. Could not find route to destination address.</li>
<li>ERR_VAL. No PCB or PCB is dual-stack</li>
<li>More errors could be returned by lower protocol layers.</li>
</ul>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__udp__raw.html#ga8d26559743e59e4b409c92a268ee67fc">udp_disconnect()</a> <a class="el" href="group__udp__raw.html#gaa0e135a5958f1f0cc83cbeb609e18743">udp_sendto()</a> </dd></dl>

</div>
</div>
<a id="gaa0e135a5958f1f0cc83cbeb609e18743"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa0e135a5958f1f0cc83cbeb609e18743">&#9670;&nbsp;</a></span>udp_sendto()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__infrastructure__errors.html#gaf02d9da80fd66b4f986d2c53d7231ddb">err_t</a> udp_sendto </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structudp__pcb.html">udp_pcb</a> *&#160;</td>
          <td class="paramname"><em>pcb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structpbuf.html">pbuf</a> *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__ipaddr.html#ga16ef96d6cde029029bbf47fee35fd67a">ip_addr_t</a> *&#160;</td>
          <td class="paramname"><em>dst_ip</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u16_t&#160;</td>
          <td class="paramname"><em>dst_port</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Send data to a specified address using UDP.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pcb</td><td>UDP PCB used to send the data. </td></tr>
    <tr><td class="paramname">p</td><td>chain of pbuf's to be sent. </td></tr>
    <tr><td class="paramname">dst_ip</td><td>Destination IP address. </td></tr>
    <tr><td class="paramname">dst_port</td><td>Destination UDP port.</td></tr>
  </table>
  </dd>
</dl>
<p>dst_ip &amp; dst_port are expected to be in the same byte order as in the pcb.</p>
<p>If the PCB already has a remote address association, it will be restored after the data is sent.</p>
<dl class="section return"><dt>Returns</dt><dd>lwIP error code (</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__udp__raw.html#gaa4546c43981f043c0ae4514d625cc3fc">udp_send</a> for possible error codes)</dd>
<dd>
<a class="el" href="group__udp__raw.html#ga8d26559743e59e4b409c92a268ee67fc">udp_disconnect()</a> <a class="el" href="group__udp__raw.html#gaa4546c43981f043c0ae4514d625cc3fc">udp_send()</a> </dd></dl>

</div>
</div>
<a id="ga83f8c873671ca7f307d14b29a0a7a142"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga83f8c873671ca7f307d14b29a0a7a142">&#9670;&nbsp;</a></span>udp_sendto_if()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__infrastructure__errors.html#gaf02d9da80fd66b4f986d2c53d7231ddb">err_t</a> udp_sendto_if </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structudp__pcb.html">udp_pcb</a> *&#160;</td>
          <td class="paramname"><em>pcb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structpbuf.html">pbuf</a> *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__ipaddr.html#ga16ef96d6cde029029bbf47fee35fd67a">ip_addr_t</a> *&#160;</td>
          <td class="paramname"><em>dst_ip</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u16_t&#160;</td>
          <td class="paramname"><em>dst_port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structnetif.html">netif</a> *&#160;</td>
          <td class="paramname"><em>netif</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Send data to a specified address using UDP. The netif used for sending can be specified.</p>
<p>This function exists mainly for DHCP, to be able to send UDP packets on a netif that is still down.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pcb</td><td>UDP PCB used to send the data. </td></tr>
    <tr><td class="paramname">p</td><td>chain of pbuf's to be sent. </td></tr>
    <tr><td class="paramname">dst_ip</td><td>Destination IP address. </td></tr>
    <tr><td class="paramname">dst_port</td><td>Destination UDP port. </td></tr>
    <tr><td class="paramname">netif</td><td>the netif used for sending.</td></tr>
  </table>
  </dd>
</dl>
<p>dst_ip &amp; dst_port are expected to be in the same byte order as in the pcb.</p>
<dl class="section return"><dt>Returns</dt><dd>lwIP error code (</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__udp__raw.html#gaa4546c43981f043c0ae4514d625cc3fc">udp_send</a> for possible error codes)</dd>
<dd>
<a class="el" href="group__udp__raw.html#ga8d26559743e59e4b409c92a268ee67fc">udp_disconnect()</a> <a class="el" href="group__udp__raw.html#gaa4546c43981f043c0ae4514d625cc3fc">udp_send()</a> </dd></dl>

</div>
</div>
<a id="gaa389827c979c766c1dae301239f7bbb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa389827c979c766c1dae301239f7bbb7">&#9670;&nbsp;</a></span>udp_sendto_if_src()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__infrastructure__errors.html#gaf02d9da80fd66b4f986d2c53d7231ddb">err_t</a> udp_sendto_if_src </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structudp__pcb.html">udp_pcb</a> *&#160;</td>
          <td class="paramname"><em>pcb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structpbuf.html">pbuf</a> *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__ipaddr.html#ga16ef96d6cde029029bbf47fee35fd67a">ip_addr_t</a> *&#160;</td>
          <td class="paramname"><em>dst_ip</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u16_t&#160;</td>
          <td class="paramname"><em>dst_port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structnetif.html">netif</a> *&#160;</td>
          <td class="paramname"><em>netif</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__ipaddr.html#ga16ef96d6cde029029bbf47fee35fd67a">ip_addr_t</a> *&#160;</td>
          <td class="paramname"><em>src_ip</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same as <a class="el" href="group__udp__raw.html#ga83f8c873671ca7f307d14b29a0a7a142">udp_sendto_if</a>, but with source address </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
