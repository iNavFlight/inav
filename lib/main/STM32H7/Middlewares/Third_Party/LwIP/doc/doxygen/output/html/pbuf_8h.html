<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>lwIP: src/include/lwip/pbuf.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">lwIP
   &#160;<span id="projectnumber">2.1.2</span>
   </div>
   <div id="projectbrief">Lightweight IP stack</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('pbuf_8h.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">pbuf.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &quot;<a class="el" href="opt_8h.html">lwip/opt.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="err_8h.html">lwip/err.h</a>&quot;</code><br />
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpbuf.html">pbuf</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpbuf__rom.html">pbuf_rom</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpbuf__custom.html">pbuf_custom</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a64174c5169b48dc17674324afd9c63b9"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pbuf_8h.html#a64174c5169b48dc17674324afd9c63b9">LWIP_SUPPORT_CUSTOM_PBUF</a>&#160;&#160;&#160;((<a class="el" href="group__lwip__opts__ipv4.html#gaf85c8bdd5035b6cada790b4cc2a209a4">IP_FRAG</a> &amp;&amp; !<a class="el" href="group__lwip__opts__netif.html#gabafb9f64a80e51b56c0abbcfc1f7e04e">LWIP_NETIF_TX_SINGLE_PBUF</a>) || (<a class="el" href="group__lwip__opts__ipv6.html#ga872e3bb3fe2212156d66b18fccc9643f">LWIP_IPV6</a> &amp;&amp; <a class="el" href="group__lwip__opts__ipv6.html#ga9ab6269f3087f6d9f7b2c7181ef043c3">LWIP_IPV6_FRAG</a>))</td></tr>
<tr class="separator:a64174c5169b48dc17674324afd9c63b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga894d91d811fd986f3cc3da828fa7beb3"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pbuf.html#ga894d91d811fd986f3cc3da828fa7beb3">PBUF_NEEDS_COPY</a>(p)&#160;&#160;&#160;((p)-&gt;type_internal &amp; <a class="el" href="pbuf_8h.html#a02789ca67766def65000b58f7fe7d03b">PBUF_TYPE_FLAG_DATA_VOLATILE</a>)</td></tr>
<tr class="separator:ga894d91d811fd986f3cc3da828fa7beb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49ab2c0662378f268ed8209bd54aaedf"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pbuf_8h.html#a49ab2c0662378f268ed8209bd54aaedf">PBUF_TYPE_FLAG_STRUCT_DATA_CONTIGUOUS</a>&#160;&#160;&#160;0x80</td></tr>
<tr class="separator:a49ab2c0662378f268ed8209bd54aaedf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02789ca67766def65000b58f7fe7d03b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pbuf_8h.html#a02789ca67766def65000b58f7fe7d03b">PBUF_TYPE_FLAG_DATA_VOLATILE</a>&#160;&#160;&#160;0x40</td></tr>
<tr class="separator:a02789ca67766def65000b58f7fe7d03b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97d4db8e0f127f61af0016c184c865ca"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pbuf_8h.html#a97d4db8e0f127f61af0016c184c865ca">PBUF_TYPE_ALLOC_SRC_MASK</a>&#160;&#160;&#160;0x0F</td></tr>
<tr class="separator:a97d4db8e0f127f61af0016c184c865ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a567a0dfa01b0e5540f9416a200ed163f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pbuf_8h.html#a567a0dfa01b0e5540f9416a200ed163f">PBUF_ALLOC_FLAG_RX</a>&#160;&#160;&#160;0x0100</td></tr>
<tr class="separator:a567a0dfa01b0e5540f9416a200ed163f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a426883d928f8f3e8fd066e616159d78f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pbuf_8h.html#a426883d928f8f3e8fd066e616159d78f">PBUF_ALLOC_FLAG_DATA_CONTIGUOUS</a>&#160;&#160;&#160;0x0200</td></tr>
<tr class="separator:a426883d928f8f3e8fd066e616159d78f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1f62ba9dc5d462e67e33c4be64c601a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pbuf_8h.html#aa1f62ba9dc5d462e67e33c4be64c601a">PBUF_TYPE_ALLOC_SRC_MASK_APP_MIN</a>&#160;&#160;&#160;0x03</td></tr>
<tr class="separator:aa1f62ba9dc5d462e67e33c4be64c601a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad686ef346759a221abdb45f64649816"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pbuf_8h.html#aad686ef346759a221abdb45f64649816">PBUF_TYPE_ALLOC_SRC_MASK_APP_MAX</a>&#160;&#160;&#160;<a class="el" href="pbuf_8h.html#a97d4db8e0f127f61af0016c184c865ca">PBUF_TYPE_ALLOC_SRC_MASK</a></td></tr>
<tr class="separator:aad686ef346759a221abdb45f64649816"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a018a6499e357f8a1373321f802a82930"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pbuf_8h.html#a018a6499e357f8a1373321f802a82930">PBUF_FLAG_PUSH</a>&#160;&#160;&#160;0x01U</td></tr>
<tr class="separator:a018a6499e357f8a1373321f802a82930"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af78a7e1815dc0e31884d095b666d997f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pbuf_8h.html#af78a7e1815dc0e31884d095b666d997f">PBUF_FLAG_IS_CUSTOM</a>&#160;&#160;&#160;0x02U</td></tr>
<tr class="separator:af78a7e1815dc0e31884d095b666d997f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8ad153151a8c157335d9c0cedc007e6"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pbuf_8h.html#ab8ad153151a8c157335d9c0cedc007e6">PBUF_FLAG_MCASTLOOP</a>&#160;&#160;&#160;0x04U</td></tr>
<tr class="separator:ab8ad153151a8c157335d9c0cedc007e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6772c16662bbb78597399add086500c0"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pbuf_8h.html#a6772c16662bbb78597399add086500c0">PBUF_FLAG_LLBCAST</a>&#160;&#160;&#160;0x08U</td></tr>
<tr class="separator:a6772c16662bbb78597399add086500c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0d56cde47aca24ef410d730d7c89887"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pbuf_8h.html#ac0d56cde47aca24ef410d730d7c89887">PBUF_FLAG_LLMCAST</a>&#160;&#160;&#160;0x10U</td></tr>
<tr class="separator:ac0d56cde47aca24ef410d730d7c89887"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36a915aa2f6a188baa2862881407971e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pbuf_8h.html#a36a915aa2f6a188baa2862881407971e">PBUF_FLAG_TCP_FIN</a>&#160;&#160;&#160;0x20U</td></tr>
<tr class="separator:a36a915aa2f6a188baa2862881407971e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac54b0f161128a32c7419c33b893a5106"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pbuf_8h.html#ac54b0f161128a32c7419c33b893a5106">PBUF_POOL_FREE_OOSEQ</a>&#160;&#160;&#160;1</td></tr>
<tr class="separator:ac54b0f161128a32c7419c33b893a5106"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a6d285ce1d910f25e511c8c38532a1dce"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pbuf_8h.html#a6d285ce1d910f25e511c8c38532a1dce">pbuf_free_custom_fn</a>) (struct <a class="el" href="structpbuf.html">pbuf</a> *p)</td></tr>
<tr class="separator:a6d285ce1d910f25e511c8c38532a1dce"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:gaee1baa59bb2f85ba575b5a8619ac1ebf"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pbuf.html#gaee1baa59bb2f85ba575b5a8619ac1ebf">pbuf_layer</a> { <br />
&#160;&#160;<a class="el" href="group__pbuf.html#ggaee1baa59bb2f85ba575b5a8619ac1ebfa2ded3594a3977f8bf9cf09552be327b5">PBUF_TRANSPORT</a> = 0 + (14 + 0 ) + 40 + 20, 
<a class="el" href="group__pbuf.html#ggaee1baa59bb2f85ba575b5a8619ac1ebfafcc1e506061ba69dfa142eb6b3da5f13">PBUF_IP</a> = 0 + (14 + 0 ) + 40, 
<a class="el" href="group__pbuf.html#ggaee1baa59bb2f85ba575b5a8619ac1ebfab4de441e737330558b609a990cd17346">PBUF_LINK</a> = 0 + (14 + 0 ), 
<a class="el" href="group__pbuf.html#ggaee1baa59bb2f85ba575b5a8619ac1ebfa0ff039585f05f9208bcb66c2d37783e2">PBUF_RAW_TX</a> = 0, 
<br />
&#160;&#160;<a class="el" href="group__pbuf.html#ggaee1baa59bb2f85ba575b5a8619ac1ebfa21116654fbab6d5a4dfeb87a1bb8f0ba">PBUF_RAW</a> = 0
<br />
 }</td></tr>
<tr class="separator:gaee1baa59bb2f85ba575b5a8619ac1ebf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab7e0e32fcc292c0d7107721766ed92fb"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pbuf.html#gab7e0e32fcc292c0d7107721766ed92fb">pbuf_type</a> { <a class="el" href="group__pbuf.html#ggab7e0e32fcc292c0d7107721766ed92fbac5e9f28455bca98944a030d4b84ecfab">PBUF_RAM</a> = ( 0x0200 | 0x80 | 0x00 ), 
<a class="el" href="group__pbuf.html#ggab7e0e32fcc292c0d7107721766ed92fbac120b0fe39efe35bb682e4aa3b82e2c9">PBUF_ROM</a> = 0x01, 
<a class="el" href="group__pbuf.html#ggab7e0e32fcc292c0d7107721766ed92fbac9b6ba960fdea6f2e8f35c8313b77e4e">PBUF_REF</a> = ( 0x40 | 0x01 ), 
<a class="el" href="group__pbuf.html#ggab7e0e32fcc292c0d7107721766ed92fbae969347127387b9b59a23ccd24b76d21">PBUF_POOL</a> = ( 0x0100 | 0x80 | 0x02 )
 }</td></tr>
<tr class="separator:gab7e0e32fcc292c0d7107721766ed92fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gacfcb0a2af918658ba0afe36499c65f47"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structpbuf.html">pbuf</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pbuf.html#gacfcb0a2af918658ba0afe36499c65f47">pbuf_alloc</a> (<a class="el" href="group__pbuf.html#gaee1baa59bb2f85ba575b5a8619ac1ebf">pbuf_layer</a> l, u16_t length, <a class="el" href="group__pbuf.html#gab7e0e32fcc292c0d7107721766ed92fb">pbuf_type</a> type)</td></tr>
<tr class="separator:gacfcb0a2af918658ba0afe36499c65f47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4caa46c6d560d9d0da2be845bc9c2fab"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structpbuf.html">pbuf</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pbuf.html#ga4caa46c6d560d9d0da2be845bc9c2fab">pbuf_alloc_reference</a> (void *payload, u16_t length, <a class="el" href="group__pbuf.html#gab7e0e32fcc292c0d7107721766ed92fb">pbuf_type</a> type)</td></tr>
<tr class="separator:ga4caa46c6d560d9d0da2be845bc9c2fab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga90fa2bbf6ea4a263ee8f7b77c75683c2"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structpbuf.html">pbuf</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pbuf.html#ga90fa2bbf6ea4a263ee8f7b77c75683c2">pbuf_alloced_custom</a> (<a class="el" href="group__pbuf.html#gaee1baa59bb2f85ba575b5a8619ac1ebf">pbuf_layer</a> l, u16_t length, <a class="el" href="group__pbuf.html#gab7e0e32fcc292c0d7107721766ed92fb">pbuf_type</a> type, struct <a class="el" href="structpbuf__custom.html">pbuf_custom</a> *p, void *payload_mem, u16_t payload_mem_len)</td></tr>
<tr class="separator:ga90fa2bbf6ea4a263ee8f7b77c75683c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga50abfe830a33a1a47a562febee66015d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pbuf.html#ga50abfe830a33a1a47a562febee66015d">pbuf_realloc</a> (struct <a class="el" href="structpbuf.html">pbuf</a> *p, u16_t size)</td></tr>
<tr class="separator:ga50abfe830a33a1a47a562febee66015d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa17c1951cf2d207b6adfd3947d91f00"><td class="memItemLeft" align="right" valign="top">u8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pbuf_8h.html#aaa17c1951cf2d207b6adfd3947d91f00">pbuf_header</a> (struct <a class="el" href="structpbuf.html">pbuf</a> *p, s16_t header_size)</td></tr>
<tr class="separator:aaa17c1951cf2d207b6adfd3947d91f00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27480c41c34021d4417691d327163626"><td class="memItemLeft" align="right" valign="top">u8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pbuf_8h.html#a27480c41c34021d4417691d327163626">pbuf_header_force</a> (struct <a class="el" href="structpbuf.html">pbuf</a> *p, s16_t header_size)</td></tr>
<tr class="separator:a27480c41c34021d4417691d327163626"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32dc14bd88dcafa25e627ab18e801815"><td class="memItemLeft" align="right" valign="top">u8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pbuf_8h.html#a32dc14bd88dcafa25e627ab18e801815">pbuf_add_header</a> (struct <a class="el" href="structpbuf.html">pbuf</a> *p, size_t header_size_increment)</td></tr>
<tr class="separator:a32dc14bd88dcafa25e627ab18e801815"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4ef8c5fbbd1447db04f8f73923e7dee"><td class="memItemLeft" align="right" valign="top">u8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pbuf_8h.html#ad4ef8c5fbbd1447db04f8f73923e7dee">pbuf_add_header_force</a> (struct <a class="el" href="structpbuf.html">pbuf</a> *p, size_t header_size_increment)</td></tr>
<tr class="separator:ad4ef8c5fbbd1447db04f8f73923e7dee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab65da7cd8f7449b3b2e57d7fa1a74ef4"><td class="memItemLeft" align="right" valign="top">u8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pbuf_8h.html#ab65da7cd8f7449b3b2e57d7fa1a74ef4">pbuf_remove_header</a> (struct <a class="el" href="structpbuf.html">pbuf</a> *p, size_t header_size)</td></tr>
<tr class="separator:ab65da7cd8f7449b3b2e57d7fa1a74ef4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25a3b8edc783896b03819a966d00845e"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structpbuf.html">pbuf</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pbuf_8h.html#a25a3b8edc783896b03819a966d00845e">pbuf_free_header</a> (struct <a class="el" href="structpbuf.html">pbuf</a> *q, u16_t size)</td></tr>
<tr class="separator:a25a3b8edc783896b03819a966d00845e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga77f6bbd69e45e542014d9c547c7da74e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pbuf.html#ga77f6bbd69e45e542014d9c547c7da74e">pbuf_ref</a> (struct <a class="el" href="structpbuf.html">pbuf</a> *p)</td></tr>
<tr class="separator:ga77f6bbd69e45e542014d9c547c7da74e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab0dd696fb4b6bc65e548944584f1738b"><td class="memItemLeft" align="right" valign="top">u8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pbuf.html#gab0dd696fb4b6bc65e548944584f1738b">pbuf_free</a> (struct <a class="el" href="structpbuf.html">pbuf</a> *p)</td></tr>
<tr class="separator:gab0dd696fb4b6bc65e548944584f1738b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5df7ac5ae59012fe9aeddba375a72190"><td class="memItemLeft" align="right" valign="top">u16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pbuf_8h.html#a5df7ac5ae59012fe9aeddba375a72190">pbuf_clen</a> (const struct <a class="el" href="structpbuf.html">pbuf</a> *p)</td></tr>
<tr class="separator:a5df7ac5ae59012fe9aeddba375a72190"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga82429084fe29015509c9b4a072707cd4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pbuf.html#ga82429084fe29015509c9b4a072707cd4">pbuf_cat</a> (struct <a class="el" href="structpbuf.html">pbuf</a> *head, struct <a class="el" href="structpbuf.html">pbuf</a> *tail)</td></tr>
<tr class="separator:ga82429084fe29015509c9b4a072707cd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga831c9a72bda1d3bd4c7b96f5a0e3b891"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pbuf.html#ga831c9a72bda1d3bd4c7b96f5a0e3b891">pbuf_chain</a> (struct <a class="el" href="structpbuf.html">pbuf</a> *head, struct <a class="el" href="structpbuf.html">pbuf</a> *tail)</td></tr>
<tr class="separator:ga831c9a72bda1d3bd4c7b96f5a0e3b891"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf3d29c4f43986b4cb5eb314d5b9729d"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structpbuf.html">pbuf</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pbuf_8h.html#abf3d29c4f43986b4cb5eb314d5b9729d">pbuf_dechain</a> (struct <a class="el" href="structpbuf.html">pbuf</a> *p)</td></tr>
<tr class="separator:abf3d29c4f43986b4cb5eb314d5b9729d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaba88511dee3df4b631fde691f421320d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__infrastructure__errors.html#gaf02d9da80fd66b4f986d2c53d7231ddb">err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pbuf.html#gaba88511dee3df4b631fde691f421320d">pbuf_copy</a> (struct <a class="el" href="structpbuf.html">pbuf</a> *p_to, const struct <a class="el" href="structpbuf.html">pbuf</a> *p_from)</td></tr>
<tr class="separator:gaba88511dee3df4b631fde691f421320d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac2f1f58fd36042e82af46f5015720899"><td class="memItemLeft" align="right" valign="top">u16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pbuf.html#gac2f1f58fd36042e82af46f5015720899">pbuf_copy_partial</a> (const struct <a class="el" href="structpbuf.html">pbuf</a> *p, void *dataptr, u16_t len, u16_t offset)</td></tr>
<tr class="separator:gac2f1f58fd36042e82af46f5015720899"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad0357ae0be17b2aacd0c301cdc86fc39"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pbuf.html#gad0357ae0be17b2aacd0c301cdc86fc39">pbuf_get_contiguous</a> (const struct <a class="el" href="structpbuf.html">pbuf</a> *p, void *buffer, size_t bufsize, u16_t len, u16_t offset)</td></tr>
<tr class="separator:gad0357ae0be17b2aacd0c301cdc86fc39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad1e31e370271335b197272af2724ca85"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__infrastructure__errors.html#gaf02d9da80fd66b4f986d2c53d7231ddb">err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pbuf.html#gad1e31e370271335b197272af2724ca85">pbuf_take</a> (struct <a class="el" href="structpbuf.html">pbuf</a> *buf, const void *dataptr, u16_t len)</td></tr>
<tr class="separator:gad1e31e370271335b197272af2724ca85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae1cf2bf7454ff87ff377b0b2262f9b44"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__infrastructure__errors.html#gaf02d9da80fd66b4f986d2c53d7231ddb">err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pbuf.html#gae1cf2bf7454ff87ff377b0b2262f9b44">pbuf_take_at</a> (struct <a class="el" href="structpbuf.html">pbuf</a> *buf, const void *dataptr, u16_t len, u16_t offset)</td></tr>
<tr class="separator:gae1cf2bf7454ff87ff377b0b2262f9b44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6a961522d81f0327aaf4d4ee6d96c583"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structpbuf.html">pbuf</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pbuf.html#ga6a961522d81f0327aaf4d4ee6d96c583">pbuf_skip</a> (struct <a class="el" href="structpbuf.html">pbuf</a> *in, u16_t in_offset, u16_t *out_offset)</td></tr>
<tr class="separator:ga6a961522d81f0327aaf4d4ee6d96c583"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga54ac7b116c6f53c704cbf74f35a8b35c"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structpbuf.html">pbuf</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pbuf.html#ga54ac7b116c6f53c704cbf74f35a8b35c">pbuf_coalesce</a> (struct <a class="el" href="structpbuf.html">pbuf</a> *p, <a class="el" href="group__pbuf.html#gaee1baa59bb2f85ba575b5a8619ac1ebf">pbuf_layer</a> layer)</td></tr>
<tr class="separator:ga54ac7b116c6f53c704cbf74f35a8b35c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafdb04fb0f37f0422fd44ec0fcec8ebd0"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structpbuf.html">pbuf</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pbuf.html#gafdb04fb0f37f0422fd44ec0fcec8ebd0">pbuf_clone</a> (<a class="el" href="group__pbuf.html#gaee1baa59bb2f85ba575b5a8619ac1ebf">pbuf_layer</a> l, <a class="el" href="group__pbuf.html#gab7e0e32fcc292c0d7107721766ed92fb">pbuf_type</a> type, struct <a class="el" href="structpbuf.html">pbuf</a> *p)</td></tr>
<tr class="separator:gafdb04fb0f37f0422fd44ec0fcec8ebd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6d803d9945bffb7ad97743f2fa503da6"><td class="memItemLeft" align="right" valign="top">u8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pbuf.html#ga6d803d9945bffb7ad97743f2fa503da6">pbuf_get_at</a> (const struct <a class="el" href="structpbuf.html">pbuf</a> *p, u16_t offset)</td></tr>
<tr class="separator:ga6d803d9945bffb7ad97743f2fa503da6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga839f342803b0cf89049744124c5a98ad"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pbuf.html#ga839f342803b0cf89049744124c5a98ad">pbuf_try_get_at</a> (const struct <a class="el" href="structpbuf.html">pbuf</a> *p, u16_t offset)</td></tr>
<tr class="separator:ga839f342803b0cf89049744124c5a98ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf76863707dc02993eae116574b1ea03f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pbuf.html#gaf76863707dc02993eae116574b1ea03f">pbuf_put_at</a> (struct <a class="el" href="structpbuf.html">pbuf</a> *p, u16_t offset, u8_t data)</td></tr>
<tr class="separator:gaf76863707dc02993eae116574b1ea03f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2170ccbbb13238380dbb203ee1b85974"><td class="memItemLeft" align="right" valign="top">u16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pbuf.html#ga2170ccbbb13238380dbb203ee1b85974">pbuf_memcmp</a> (const struct <a class="el" href="structpbuf.html">pbuf</a> *p, u16_t offset, const void *s2, u16_t n)</td></tr>
<tr class="separator:ga2170ccbbb13238380dbb203ee1b85974"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga18c164a6e4a24d89ea9eb7571a886448"><td class="memItemLeft" align="right" valign="top">u16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pbuf.html#ga18c164a6e4a24d89ea9eb7571a886448">pbuf_memfind</a> (const struct <a class="el" href="structpbuf.html">pbuf</a> *p, const void *<a class="el" href="structmem.html">mem</a>, u16_t mem_len, u16_t start_offset)</td></tr>
<tr class="separator:ga18c164a6e4a24d89ea9eb7571a886448"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ba3f7b705309ceadb147692fd5a1c7d"><td class="memItemLeft" align="right" valign="top">u16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pbuf_8h.html#a9ba3f7b705309ceadb147692fd5a1c7d">pbuf_strstr</a> (const struct <a class="el" href="structpbuf.html">pbuf</a> *p, const char *substr)</td></tr>
<tr class="separator:a9ba3f7b705309ceadb147692fd5a1c7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>pbuf API </p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a id="a64174c5169b48dc17674324afd9c63b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64174c5169b48dc17674324afd9c63b9">&#9670;&nbsp;</a></span>LWIP_SUPPORT_CUSTOM_PBUF</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LWIP_SUPPORT_CUSTOM_PBUF&#160;&#160;&#160;((<a class="el" href="group__lwip__opts__ipv4.html#gaf85c8bdd5035b6cada790b4cc2a209a4">IP_FRAG</a> &amp;&amp; !<a class="el" href="group__lwip__opts__netif.html#gabafb9f64a80e51b56c0abbcfc1f7e04e">LWIP_NETIF_TX_SINGLE_PBUF</a>) || (<a class="el" href="group__lwip__opts__ipv6.html#ga872e3bb3fe2212156d66b18fccc9643f">LWIP_IPV6</a> &amp;&amp; <a class="el" href="group__lwip__opts__ipv6.html#ga9ab6269f3087f6d9f7b2c7181ef043c3">LWIP_IPV6_FRAG</a>))</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>LWIP_SUPPORT_CUSTOM_PBUF==1: Custom pbufs behave much like their pbuf type but they are allocated by external code (initialised by calling <a class="el" href="group__pbuf.html#ga90fa2bbf6ea4a263ee8f7b77c75683c2">pbuf_alloced_custom()</a>) and when pbuf_free gives up their last reference, they are freed by calling pbuf_custom-&gt;custom_free_function(). Currently, the <a class="el" href="structpbuf__custom.html">pbuf_custom</a> code is only needed for one specific configuration of IP_FRAG, unless required by external driver/application code. </p>

</div>
</div>
<a id="a426883d928f8f3e8fd066e616159d78f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a426883d928f8f3e8fd066e616159d78f">&#9670;&nbsp;</a></span>PBUF_ALLOC_FLAG_DATA_CONTIGUOUS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PBUF_ALLOC_FLAG_DATA_CONTIGUOUS&#160;&#160;&#160;0x0200</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Indicates the application needs the pbuf payload to be in one piece </p>

</div>
</div>
<a id="a567a0dfa01b0e5540f9416a200ed163f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a567a0dfa01b0e5540f9416a200ed163f">&#9670;&nbsp;</a></span>PBUF_ALLOC_FLAG_RX</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PBUF_ALLOC_FLAG_RX&#160;&#160;&#160;0x0100</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Indicates this pbuf is used for RX (if not set, indicates use for TX). This information can be used to keep some spare RX buffers e.g. for receiving TCP ACKs to unblock a connection) </p>

</div>
</div>
<a id="af78a7e1815dc0e31884d095b666d997f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af78a7e1815dc0e31884d095b666d997f">&#9670;&nbsp;</a></span>PBUF_FLAG_IS_CUSTOM</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PBUF_FLAG_IS_CUSTOM&#160;&#160;&#160;0x02U</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>indicates this is a custom pbuf: pbuf_free calls pbuf_custom-&gt;custom_free_function() when the last reference is released (plus custom PBUF_RAM cannot be trimmed) </p>

</div>
</div>
<a id="a6772c16662bbb78597399add086500c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6772c16662bbb78597399add086500c0">&#9670;&nbsp;</a></span>PBUF_FLAG_LLBCAST</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PBUF_FLAG_LLBCAST&#160;&#160;&#160;0x08U</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>indicates this pbuf was received as link-level broadcast </p>

</div>
</div>
<a id="ac0d56cde47aca24ef410d730d7c89887"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0d56cde47aca24ef410d730d7c89887">&#9670;&nbsp;</a></span>PBUF_FLAG_LLMCAST</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PBUF_FLAG_LLMCAST&#160;&#160;&#160;0x10U</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>indicates this pbuf was received as link-level multicast </p>

</div>
</div>
<a id="ab8ad153151a8c157335d9c0cedc007e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8ad153151a8c157335d9c0cedc007e6">&#9670;&nbsp;</a></span>PBUF_FLAG_MCASTLOOP</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PBUF_FLAG_MCASTLOOP&#160;&#160;&#160;0x04U</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>indicates this pbuf is UDP multicast to be looped back </p>

</div>
</div>
<a id="a018a6499e357f8a1373321f802a82930"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a018a6499e357f8a1373321f802a82930">&#9670;&nbsp;</a></span>PBUF_FLAG_PUSH</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PBUF_FLAG_PUSH&#160;&#160;&#160;0x01U</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>indicates this packet's data should be immediately passed to the application </p>

</div>
</div>
<a id="a36a915aa2f6a188baa2862881407971e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36a915aa2f6a188baa2862881407971e">&#9670;&nbsp;</a></span>PBUF_FLAG_TCP_FIN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PBUF_FLAG_TCP_FIN&#160;&#160;&#160;0x20U</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>indicates this pbuf includes a TCP FIN flag </p>

</div>
</div>
<a id="ac54b0f161128a32c7419c33b893a5106"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac54b0f161128a32c7419c33b893a5106">&#9670;&nbsp;</a></span>PBUF_POOL_FREE_OOSEQ</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PBUF_POOL_FREE_OOSEQ&#160;&#160;&#160;1</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Define this to 0 to prevent freeing ooseq pbufs when the PBUF_POOL is empty </p>

</div>
</div>
<a id="a97d4db8e0f127f61af0016c184c865ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97d4db8e0f127f61af0016c184c865ca">&#9670;&nbsp;</a></span>PBUF_TYPE_ALLOC_SRC_MASK</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PBUF_TYPE_ALLOC_SRC_MASK&#160;&#160;&#160;0x0F</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>4 bits are reserved for 16 allocation sources (e.g. heap, pool1, pool2, etc) Internally, we use: 0=heap, 1=MEMP_PBUF, 2=MEMP_PBUF_POOL -&gt; 13 types free </p>

</div>
</div>
<a id="aad686ef346759a221abdb45f64649816"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad686ef346759a221abdb45f64649816">&#9670;&nbsp;</a></span>PBUF_TYPE_ALLOC_SRC_MASK_APP_MAX</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PBUF_TYPE_ALLOC_SRC_MASK_APP_MAX&#160;&#160;&#160;<a class="el" href="pbuf_8h.html#a97d4db8e0f127f61af0016c184c865ca">PBUF_TYPE_ALLOC_SRC_MASK</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Last pbuf allocation type for applications </p>

</div>
</div>
<a id="aa1f62ba9dc5d462e67e33c4be64c601a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1f62ba9dc5d462e67e33c4be64c601a">&#9670;&nbsp;</a></span>PBUF_TYPE_ALLOC_SRC_MASK_APP_MIN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PBUF_TYPE_ALLOC_SRC_MASK_APP_MIN&#160;&#160;&#160;0x03</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>First pbuf allocation type for applications </p>

</div>
</div>
<a id="a02789ca67766def65000b58f7fe7d03b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02789ca67766def65000b58f7fe7d03b">&#9670;&nbsp;</a></span>PBUF_TYPE_FLAG_DATA_VOLATILE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PBUF_TYPE_FLAG_DATA_VOLATILE&#160;&#160;&#160;0x40</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Indicates the data stored in this pbuf can change. If this pbuf needs to be queued, it must be copied/duplicated. </p>

</div>
</div>
<a id="a49ab2c0662378f268ed8209bd54aaedf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49ab2c0662378f268ed8209bd54aaedf">&#9670;&nbsp;</a></span>PBUF_TYPE_FLAG_STRUCT_DATA_CONTIGUOUS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PBUF_TYPE_FLAG_STRUCT_DATA_CONTIGUOUS&#160;&#160;&#160;0x80</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Indicates that the payload directly follows the struct pbuf. This makes <a class="el" href="pbuf_8h.html#aaa17c1951cf2d207b6adfd3947d91f00">pbuf_header</a> work in both directions. </p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="a6d285ce1d910f25e511c8c38532a1dce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d285ce1d910f25e511c8c38532a1dce">&#9670;&nbsp;</a></span>pbuf_free_custom_fn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* pbuf_free_custom_fn) (struct <a class="el" href="structpbuf.html">pbuf</a> *p)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Prototype for a function to free a custom pbuf </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a32dc14bd88dcafa25e627ab18e801815"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32dc14bd88dcafa25e627ab18e801815">&#9670;&nbsp;</a></span>pbuf_add_header()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u8_t pbuf_add_header </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structpbuf.html">pbuf</a> *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>header_size_increment</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adjusts the payload pointer to reveal headers in the payload.</p>
<p>Adjusts the -&gt;payload pointer so that space for a header appears in the pbuf payload.</p>
<p>The -&gt;payload, -&gt;tot_len and -&gt;len fields are adjusted.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>pbuf to change the header size. </td></tr>
    <tr><td class="paramname">header_size_increment</td><td>Number of bytes to increment header size which increases the size of the pbuf. New space is on the front. If header_size_increment is 0, this function does nothing and returns successful.</td></tr>
  </table>
  </dd>
</dl>
<p>PBUF_ROM and PBUF_REF type buffers cannot have their sizes increased, so the call will fail. A check is made that the increase in header size does not move the payload pointer in front of the start of the buffer.</p>
<dl class="section return"><dt>Returns</dt><dd>non-zero on failure, zero on success. </dd></dl>

</div>
</div>
<a id="ad4ef8c5fbbd1447db04f8f73923e7dee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4ef8c5fbbd1447db04f8f73923e7dee">&#9670;&nbsp;</a></span>pbuf_add_header_force()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u8_t pbuf_add_header_force </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structpbuf.html">pbuf</a> *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>header_size_increment</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same as <a class="el" href="pbuf_8h.html#a32dc14bd88dcafa25e627ab18e801815">pbuf_add_header</a> but does not check if 'header_size &gt; 0' is allowed. This is used internally only, to allow PBUF_REF for RX. </p>

</div>
</div>
<a id="a5df7ac5ae59012fe9aeddba375a72190"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5df7ac5ae59012fe9aeddba375a72190">&#9670;&nbsp;</a></span>pbuf_clen()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u16_t pbuf_clen </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structpbuf.html">pbuf</a> *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Count number of pbufs in a chain</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>first pbuf of chain </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of pbufs in a chain </dd></dl>

</div>
</div>
<a id="abf3d29c4f43986b4cb5eb314d5b9729d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf3d29c4f43986b4cb5eb314d5b9729d">&#9670;&nbsp;</a></span>pbuf_dechain()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structpbuf.html">pbuf</a>* pbuf_dechain </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structpbuf.html">pbuf</a> *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Dechains the first pbuf from its succeeding pbufs in the chain.</p>
<p>Makes p-&gt;tot_len field equal to p-&gt;len. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>pbuf to dechain </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>remainder of the pbuf chain, or NULL if it was de-allocated. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>May not be called on a packet queue. </dd></dl>

</div>
</div>
<a id="a25a3b8edc783896b03819a966d00845e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25a3b8edc783896b03819a966d00845e">&#9670;&nbsp;</a></span>pbuf_free_header()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structpbuf.html">pbuf</a>* pbuf_free_header </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structpbuf.html">pbuf</a> *&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u16_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Similar to pbuf_header(-size) but de-refs header pbufs for (size &gt;= p-&gt;len)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">q</td><td>pbufs to operate on </td></tr>
    <tr><td class="paramname">size</td><td>The number of bytes to remove from the beginning of the pbuf list. While size &gt;= p-&gt;len, pbufs are freed. ATTENTION: this is the opposite direction as <a class="el" href="pbuf_8h.html#aaa17c1951cf2d207b6adfd3947d91f00">pbuf_header</a>, but takes an u16_t not s16_t! </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the new head pbuf </dd></dl>

</div>
</div>
<a id="aaa17c1951cf2d207b6adfd3947d91f00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa17c1951cf2d207b6adfd3947d91f00">&#9670;&nbsp;</a></span>pbuf_header()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u8_t pbuf_header </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structpbuf.html">pbuf</a> *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">s16_t&#160;</td>
          <td class="paramname"><em>header_size_increment</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adjusts the payload pointer to hide or reveal headers in the payload.</p>
<p>Adjusts the -&gt;payload pointer so that space for a header (dis)appears in the pbuf payload.</p>
<p>The -&gt;payload, -&gt;tot_len and -&gt;len fields are adjusted.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>pbuf to change the header size. </td></tr>
    <tr><td class="paramname">header_size_increment</td><td>Number of bytes to increment header size which increases the size of the pbuf. New space is on the front. (Using a negative value decreases the header size.) If header_size_increment is 0, this function does nothing and returns successful.</td></tr>
  </table>
  </dd>
</dl>
<p>PBUF_ROM and PBUF_REF type buffers cannot have their sizes increased, so the call will fail. A check is made that the increase in header size does not move the payload pointer in front of the start of the buffer. </p><dl class="section return"><dt>Returns</dt><dd>non-zero on failure, zero on success. </dd></dl>

</div>
</div>
<a id="a27480c41c34021d4417691d327163626"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27480c41c34021d4417691d327163626">&#9670;&nbsp;</a></span>pbuf_header_force()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u8_t pbuf_header_force </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structpbuf.html">pbuf</a> *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">s16_t&#160;</td>
          <td class="paramname"><em>header_size_increment</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same as pbuf_header but does not check if 'header_size &gt; 0' is allowed. This is used internally only, to allow PBUF_REF for RX. </p>

</div>
</div>
<a id="ab65da7cd8f7449b3b2e57d7fa1a74ef4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab65da7cd8f7449b3b2e57d7fa1a74ef4">&#9670;&nbsp;</a></span>pbuf_remove_header()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u8_t pbuf_remove_header </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structpbuf.html">pbuf</a> *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>header_size_decrement</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adjusts the payload pointer to hide headers in the payload.</p>
<p>Adjusts the -&gt;payload pointer so that space for a header disappears in the pbuf payload.</p>
<p>The -&gt;payload, -&gt;tot_len and -&gt;len fields are adjusted.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>pbuf to change the header size. </td></tr>
    <tr><td class="paramname">header_size_decrement</td><td>Number of bytes to decrement header size which decreases the size of the pbuf. If header_size_decrement is 0, this function does nothing and returns successful. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>non-zero on failure, zero on success. </dd></dl>

</div>
</div>
<a id="a9ba3f7b705309ceadb147692fd5a1c7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ba3f7b705309ceadb147692fd5a1c7d">&#9670;&nbsp;</a></span>pbuf_strstr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u16_t pbuf_strstr </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structpbuf.html">pbuf</a> *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>substr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find occurrence of substr with length substr_len in pbuf p, start at offset start_offset WARNING: in contrast to strstr(), this one does not stop at the first \0 in the pbuf/source string!</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>pbuf to search, maximum length is 0xFFFE since 0xFFFF is used as return value 'not found' </td></tr>
    <tr><td class="paramname">substr</td><td>string to search for in p, maximum length is 0xFFFE </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0xFFFF if substr was not found in p or the index where it was found </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_68267d1309a1af8e8297ef4c3efbcdba.html">src</a></li><li class="navelem"><a class="el" href="dir_b0856f6b0d80ccb263b2f415c91f9e17.html">include</a></li><li class="navelem"><a class="el" href="dir_4e6b3cf33a61b6caac9c8ac30c866f37.html">lwip</a></li><li class="navelem"><a class="el" href="pbuf_8h.html">pbuf.h</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
