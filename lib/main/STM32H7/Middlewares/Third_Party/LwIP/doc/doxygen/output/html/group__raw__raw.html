<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>lwIP: RAW</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">lwIP
   &#160;<span id="projectnumber">2.1.2</span>
   </div>
   <div id="projectbrief">Lightweight IP stack</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__raw__raw.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">RAW<div class="ingroups"><a class="el" href="group__api.html">APIs</a> &raquo; <a class="el" href="group__callbackstyle__api.html">&quot;raw&quot; APIs</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga8576dbbc7f03797525d2cdb7ec3b9fe4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__infrastructure__errors.html#gaf02d9da80fd66b4f986d2c53d7231ddb">err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__raw__raw.html#ga8576dbbc7f03797525d2cdb7ec3b9fe4">raw_bind</a> (struct <a class="el" href="structraw__pcb.html">raw_pcb</a> *pcb, const <a class="el" href="group__ipaddr.html#ga16ef96d6cde029029bbf47fee35fd67a">ip_addr_t</a> *ipaddr)</td></tr>
<tr class="separator:ga8576dbbc7f03797525d2cdb7ec3b9fe4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa124ac8a9479aebefe2c953629df591a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__raw__raw.html#gaa124ac8a9479aebefe2c953629df591a">raw_bind_netif</a> (struct <a class="el" href="structraw__pcb.html">raw_pcb</a> *pcb, const struct <a class="el" href="structnetif.html">netif</a> *<a class="el" href="structnetif.html">netif</a>)</td></tr>
<tr class="separator:gaa124ac8a9479aebefe2c953629df591a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga31bb29c964d5e2f734e563485fc25168"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__infrastructure__errors.html#gaf02d9da80fd66b4f986d2c53d7231ddb">err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__raw__raw.html#ga31bb29c964d5e2f734e563485fc25168">raw_connect</a> (struct <a class="el" href="structraw__pcb.html">raw_pcb</a> *pcb, const <a class="el" href="group__ipaddr.html#ga16ef96d6cde029029bbf47fee35fd67a">ip_addr_t</a> *ipaddr)</td></tr>
<tr class="separator:ga31bb29c964d5e2f734e563485fc25168"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7634c0306e2c6f8040e35f6547e8d3ef"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__raw__raw.html#ga7634c0306e2c6f8040e35f6547e8d3ef">raw_disconnect</a> (struct <a class="el" href="structraw__pcb.html">raw_pcb</a> *pcb)</td></tr>
<tr class="separator:ga7634c0306e2c6f8040e35f6547e8d3ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadf84e4e6911ce3c0d7f5669b6edac426"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__raw__raw.html#gadf84e4e6911ce3c0d7f5669b6edac426">raw_recv</a> (struct <a class="el" href="structraw__pcb.html">raw_pcb</a> *pcb, <a class="el" href="raw_8h.html#a17edd059f34f45a770fe2fa458ecf4dd">raw_recv_fn</a> <a class="el" href="group__socket.html#gadd7ae45df7c005619eb1126542231e9b">recv</a>, void *recv_arg)</td></tr>
<tr class="separator:gadf84e4e6911ce3c0d7f5669b6edac426"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga09427456070fb610cc7795d23dedc159"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__infrastructure__errors.html#gaf02d9da80fd66b4f986d2c53d7231ddb">err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__raw__raw.html#ga09427456070fb610cc7795d23dedc159">raw_sendto</a> (struct <a class="el" href="structraw__pcb.html">raw_pcb</a> *pcb, struct <a class="el" href="structpbuf.html">pbuf</a> *p, const <a class="el" href="group__ipaddr.html#ga16ef96d6cde029029bbf47fee35fd67a">ip_addr_t</a> *ipaddr)</td></tr>
<tr class="separator:ga09427456070fb610cc7795d23dedc159"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2fe3765ae938a3f7c53dc7051b7ab0b1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__infrastructure__errors.html#gaf02d9da80fd66b4f986d2c53d7231ddb">err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__raw__raw.html#ga2fe3765ae938a3f7c53dc7051b7ab0b1">raw_sendto_if_src</a> (struct <a class="el" href="structraw__pcb.html">raw_pcb</a> *pcb, struct <a class="el" href="structpbuf.html">pbuf</a> *p, const <a class="el" href="group__ipaddr.html#ga16ef96d6cde029029bbf47fee35fd67a">ip_addr_t</a> *dst_ip, struct <a class="el" href="structnetif.html">netif</a> *<a class="el" href="structnetif.html">netif</a>, const <a class="el" href="group__ipaddr.html#ga16ef96d6cde029029bbf47fee35fd67a">ip_addr_t</a> *src_ip)</td></tr>
<tr class="separator:ga2fe3765ae938a3f7c53dc7051b7ab0b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabbc2e7c7a1b4429f420562d4f31b3a9d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__infrastructure__errors.html#gaf02d9da80fd66b4f986d2c53d7231ddb">err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__raw__raw.html#gabbc2e7c7a1b4429f420562d4f31b3a9d">raw_send</a> (struct <a class="el" href="structraw__pcb.html">raw_pcb</a> *pcb, struct <a class="el" href="structpbuf.html">pbuf</a> *p)</td></tr>
<tr class="separator:gabbc2e7c7a1b4429f420562d4f31b3a9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8db62f7d75f722a653b5368305a47e16"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__raw__raw.html#ga8db62f7d75f722a653b5368305a47e16">raw_remove</a> (struct <a class="el" href="structraw__pcb.html">raw_pcb</a> *pcb)</td></tr>
<tr class="separator:ga8db62f7d75f722a653b5368305a47e16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3217f096ea86728e011f91b249933e8f"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structraw__pcb.html">raw_pcb</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__raw__raw.html#ga3217f096ea86728e011f91b249933e8f">raw_new</a> (u8_t proto)</td></tr>
<tr class="separator:ga3217f096ea86728e011f91b249933e8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3292b7ed2271ac29983edcef16dcbc11"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structraw__pcb.html">raw_pcb</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__raw__raw.html#ga3292b7ed2271ac29983edcef16dcbc11">raw_new_ip_type</a> (u8_t type, u8_t proto)</td></tr>
<tr class="separator:ga3292b7ed2271ac29983edcef16dcbc11"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Implementation of raw protocol PCBs for low-level handling of different types of protocols besides (or overriding) those already available in lwIP.<br />
</p><dl class="section see"><dt>See also</dt><dd><a class="el" href="group__api.html">APIs</a> </dd></dl>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga8576dbbc7f03797525d2cdb7ec3b9fe4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8576dbbc7f03797525d2cdb7ec3b9fe4">&#9670;&nbsp;</a></span>raw_bind()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__infrastructure__errors.html#gaf02d9da80fd66b4f986d2c53d7231ddb">err_t</a> raw_bind </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structraw__pcb.html">raw_pcb</a> *&#160;</td>
          <td class="paramname"><em>pcb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__ipaddr.html#ga16ef96d6cde029029bbf47fee35fd67a">ip_addr_t</a> *&#160;</td>
          <td class="paramname"><em>ipaddr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Bind a RAW PCB.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pcb</td><td>RAW PCB to be bound with a local address ipaddr. </td></tr>
    <tr><td class="paramname">ipaddr</td><td>local IP address to bind with. Use IP4_ADDR_ANY to bind to all local interfaces.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>lwIP error code.<ul>
<li>ERR_OK. Successful. No error occurred.</li>
<li>ERR_USE. The specified IP address is already bound to by another RAW PCB.</li>
</ul>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__raw__raw.html#ga7634c0306e2c6f8040e35f6547e8d3ef">raw_disconnect()</a> </dd></dl>

</div>
</div>
<a id="gaa124ac8a9479aebefe2c953629df591a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa124ac8a9479aebefe2c953629df591a">&#9670;&nbsp;</a></span>raw_bind_netif()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void raw_bind_netif </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structraw__pcb.html">raw_pcb</a> *&#160;</td>
          <td class="paramname"><em>pcb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structnetif.html">netif</a> *&#160;</td>
          <td class="paramname"><em>netif</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Bind an RAW PCB to a specific netif. After calling this function, all packets received via this PCB are guaranteed to have come in via the specified netif, and all outgoing packets will go out via the specified netif.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pcb</td><td>RAW PCB to be bound with netif. </td></tr>
    <tr><td class="paramname">netif</td><td>netif to bind to. Can be NULL.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__raw__raw.html#ga7634c0306e2c6f8040e35f6547e8d3ef">raw_disconnect()</a> </dd></dl>

</div>
</div>
<a id="ga31bb29c964d5e2f734e563485fc25168"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga31bb29c964d5e2f734e563485fc25168">&#9670;&nbsp;</a></span>raw_connect()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__infrastructure__errors.html#gaf02d9da80fd66b4f986d2c53d7231ddb">err_t</a> raw_connect </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structraw__pcb.html">raw_pcb</a> *&#160;</td>
          <td class="paramname"><em>pcb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__ipaddr.html#ga16ef96d6cde029029bbf47fee35fd67a">ip_addr_t</a> *&#160;</td>
          <td class="paramname"><em>ipaddr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Connect an RAW PCB. This function is required by upper layers of lwip. Using the raw api you could use <a class="el" href="group__raw__raw.html#ga09427456070fb610cc7795d23dedc159">raw_sendto()</a> instead</p>
<p>This will associate the RAW PCB with the remote address.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pcb</td><td>RAW PCB to be connected with remote address ipaddr and port. </td></tr>
    <tr><td class="paramname">ipaddr</td><td>remote IP address to connect with.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>lwIP error code</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__raw__raw.html#ga7634c0306e2c6f8040e35f6547e8d3ef">raw_disconnect()</a> and <a class="el" href="group__raw__raw.html#ga09427456070fb610cc7795d23dedc159">raw_sendto()</a> </dd></dl>

</div>
</div>
<a id="ga7634c0306e2c6f8040e35f6547e8d3ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7634c0306e2c6f8040e35f6547e8d3ef">&#9670;&nbsp;</a></span>raw_disconnect()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void raw_disconnect </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structraw__pcb.html">raw_pcb</a> *&#160;</td>
          <td class="paramname"><em>pcb</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Disconnect a RAW PCB.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pcb</td><td>the raw pcb to disconnect. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga3217f096ea86728e011f91b249933e8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3217f096ea86728e011f91b249933e8f">&#9670;&nbsp;</a></span>raw_new()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structraw__pcb.html">raw_pcb</a>* raw_new </td>
          <td>(</td>
          <td class="paramtype">u8_t&#160;</td>
          <td class="paramname"><em>proto</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a RAW PCB.</p>
<dl class="section return"><dt>Returns</dt><dd>The RAW PCB which was created. NULL if the PCB data structure could not be allocated.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">proto</td><td>the protocol number of the IPs payload (e.g. IP_PROTO_ICMP)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__raw__raw.html#ga8db62f7d75f722a653b5368305a47e16">raw_remove()</a> </dd></dl>

</div>
</div>
<a id="ga3292b7ed2271ac29983edcef16dcbc11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3292b7ed2271ac29983edcef16dcbc11">&#9670;&nbsp;</a></span>raw_new_ip_type()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structraw__pcb.html">raw_pcb</a>* raw_new_ip_type </td>
          <td>(</td>
          <td class="paramtype">u8_t&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8_t&#160;</td>
          <td class="paramname"><em>proto</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a RAW PCB for specific IP type.</p>
<dl class="section return"><dt>Returns</dt><dd>The RAW PCB which was created. NULL if the PCB data structure could not be allocated.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>IP address type, see <a class="el" href="group__ipaddr.html#gaf2142f0dfdcc938e2db16aa745ed585c">lwip_ip_addr_type</a> definitions. If you want to listen to IPv4 and IPv6 (dual-stack) packets, supply <a class="el" href="group__ipaddr.html#ggaf2142f0dfdcc938e2db16aa745ed585cac6b2c99cf920e08efcb55dc40e42944e">IPADDR_TYPE_ANY</a> as argument and bind to <a class="el" href="group__ipaddr.html#gabe43b154533b73585c4e58f568370ede">IP_ANY_TYPE</a>. </td></tr>
    <tr><td class="paramname">proto</td><td>the protocol number (next header) of the IPv6 packet payload (e.g. IP6_NEXTH_ICMP6)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__raw__raw.html#ga8db62f7d75f722a653b5368305a47e16">raw_remove()</a> </dd></dl>

</div>
</div>
<a id="gadf84e4e6911ce3c0d7f5669b6edac426"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadf84e4e6911ce3c0d7f5669b6edac426">&#9670;&nbsp;</a></span>raw_recv()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void raw_recv </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structraw__pcb.html">raw_pcb</a> *&#160;</td>
          <td class="paramname"><em>pcb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="raw_8h.html#a17edd059f34f45a770fe2fa458ecf4dd">raw_recv_fn</a>&#160;</td>
          <td class="paramname"><em>recv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>recv_arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the callback function for received packets that match the raw PCB's protocol and binding.</p>
<p>The callback function MUST either</p><ul>
<li>eat the packet by calling <a class="el" href="group__pbuf.html#gab0dd696fb4b6bc65e548944584f1738b">pbuf_free()</a> and returning non-zero. The packet will not be passed to other raw PCBs or other protocol layers.</li>
<li>not free the packet, and return zero. The packet will be matched against further PCBs and/or forwarded to another protocol layers. </li>
</ul>

</div>
</div>
<a id="ga8db62f7d75f722a653b5368305a47e16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8db62f7d75f722a653b5368305a47e16">&#9670;&nbsp;</a></span>raw_remove()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void raw_remove </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structraw__pcb.html">raw_pcb</a> *&#160;</td>
          <td class="paramname"><em>pcb</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Remove an RAW PCB.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pcb</td><td>RAW PCB to be removed. The PCB is removed from the list of RAW PCB's and the data structure is freed from memory.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__raw__raw.html#ga3217f096ea86728e011f91b249933e8f">raw_new()</a> </dd></dl>

</div>
</div>
<a id="gabbc2e7c7a1b4429f420562d4f31b3a9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabbc2e7c7a1b4429f420562d4f31b3a9d">&#9670;&nbsp;</a></span>raw_send()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__infrastructure__errors.html#gaf02d9da80fd66b4f986d2c53d7231ddb">err_t</a> raw_send </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structraw__pcb.html">raw_pcb</a> *&#160;</td>
          <td class="paramname"><em>pcb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structpbuf.html">pbuf</a> *&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Send the raw IP packet to the address given by <a class="el" href="group__raw__raw.html#ga31bb29c964d5e2f734e563485fc25168">raw_connect()</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pcb</td><td>the raw pcb which to send </td></tr>
    <tr><td class="paramname">p</td><td>the IP payload to send </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga09427456070fb610cc7795d23dedc159"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga09427456070fb610cc7795d23dedc159">&#9670;&nbsp;</a></span>raw_sendto()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__infrastructure__errors.html#gaf02d9da80fd66b4f986d2c53d7231ddb">err_t</a> raw_sendto </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structraw__pcb.html">raw_pcb</a> *&#160;</td>
          <td class="paramname"><em>pcb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structpbuf.html">pbuf</a> *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__ipaddr.html#ga16ef96d6cde029029bbf47fee35fd67a">ip_addr_t</a> *&#160;</td>
          <td class="paramname"><em>ipaddr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Send the raw IP packet to the given address. An IP header will be prepended to the packet, unless the RAW_FLAGS_HDRINCL flag is set on the PCB. In that case, the packet must include an IP header, which will then be sent as is.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pcb</td><td>the raw pcb which to send </td></tr>
    <tr><td class="paramname">p</td><td>the IP payload to send </td></tr>
    <tr><td class="paramname">ipaddr</td><td>the destination address of the IP packet </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga2fe3765ae938a3f7c53dc7051b7ab0b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2fe3765ae938a3f7c53dc7051b7ab0b1">&#9670;&nbsp;</a></span>raw_sendto_if_src()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__infrastructure__errors.html#gaf02d9da80fd66b4f986d2c53d7231ddb">err_t</a> raw_sendto_if_src </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structraw__pcb.html">raw_pcb</a> *&#160;</td>
          <td class="paramname"><em>pcb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structpbuf.html">pbuf</a> *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__ipaddr.html#ga16ef96d6cde029029bbf47fee35fd67a">ip_addr_t</a> *&#160;</td>
          <td class="paramname"><em>dst_ip</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structnetif.html">netif</a> *&#160;</td>
          <td class="paramname"><em>netif</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__ipaddr.html#ga16ef96d6cde029029bbf47fee35fd67a">ip_addr_t</a> *&#160;</td>
          <td class="paramname"><em>src_ip</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Send the raw IP packet to the given address, using a particular outgoing netif and source IP address. An IP header will be prepended to the packet, unless the RAW_FLAGS_HDRINCL flag is set on the PCB. In that case, the packet must include an IP header, which will then be sent as is.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pcb</td><td>RAW PCB used to send the data </td></tr>
    <tr><td class="paramname">p</td><td>chain of pbufs to be sent </td></tr>
    <tr><td class="paramname">dst_ip</td><td>destination IP address </td></tr>
    <tr><td class="paramname">netif</td><td>the netif used for sending </td></tr>
    <tr><td class="paramname">src_ip</td><td>source IP address </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
