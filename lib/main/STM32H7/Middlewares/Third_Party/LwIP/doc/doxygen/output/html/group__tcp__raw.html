<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>lwIP: TCP</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">lwIP
   &#160;<span id="projectnumber">2.1.2</span>
   </div>
   <div id="projectbrief">Lightweight IP stack</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__tcp__raw.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#groups">Modules</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">TCP<div class="ingroups"><a class="el" href="group__api.html">APIs</a> &raquo; <a class="el" href="group__callbackstyle__api.html">&quot;raw&quot; APIs</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="groups"></a>
Modules</h2></td></tr>
<tr class="memitem:group__tcp__raw__extargs"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tcp__raw__extargs.html">ext arguments</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:gab0b45a01dcd461e5b8df2a1d9ddda134"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tcp__raw.html#gab0b45a01dcd461e5b8df2a1d9ddda134">tcp_mss</a>(pcb)&#160;&#160;&#160;((pcb)-&gt;mss)</td></tr>
<tr class="separator:gab0b45a01dcd461e5b8df2a1d9ddda134"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad1a95f09deb49cd7341d35527d6d3e2f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tcp__raw.html#gad1a95f09deb49cd7341d35527d6d3e2f">tcp_sndbuf</a>(pcb)&#160;&#160;&#160;(TCPWND16((pcb)-&gt;snd_buf))</td></tr>
<tr class="separator:gad1a95f09deb49cd7341d35527d6d3e2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga53ee4364718e84dc42cb1e0179deb1f4"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tcp__raw.html#ga53ee4364718e84dc42cb1e0179deb1f4">tcp_sndqueuelen</a>(pcb)&#160;&#160;&#160;((pcb)-&gt;snd_queuelen)</td></tr>
<tr class="separator:ga53ee4364718e84dc42cb1e0179deb1f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5b5c0093efff4466bda06d45f12a4633"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tcp__raw.html#ga5b5c0093efff4466bda06d45f12a4633">tcp_nagle_disable</a>(pcb)&#160;&#160;&#160;tcp_set_flags(pcb, TF_NODELAY)</td></tr>
<tr class="separator:ga5b5c0093efff4466bda06d45f12a4633"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9dfcdb8a05533b07dca91cf7e784f88f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tcp__raw.html#ga9dfcdb8a05533b07dca91cf7e784f88f">tcp_nagle_enable</a>(pcb)&#160;&#160;&#160;tcp_clear_flags(pcb, TF_NODELAY)</td></tr>
<tr class="separator:ga9dfcdb8a05533b07dca91cf7e784f88f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9398061411b4af900160233aa3b1a286"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tcp__raw.html#ga9398061411b4af900160233aa3b1a286">tcp_nagle_disabled</a>(pcb)&#160;&#160;&#160;tcp_is_flag_set(pcb, TF_NODELAY)</td></tr>
<tr class="separator:ga9398061411b4af900160233aa3b1a286"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6b2a4efb1fc15d7d85cb71cb2a1d1066"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tcp__raw.html#ga6b2a4efb1fc15d7d85cb71cb2a1d1066">tcp_listen</a>(pcb)&#160;&#160;&#160;<a class="el" href="group__tcp__raw.html#gaeff14f321d1eecd0431611f382fcd338">tcp_listen_with_backlog</a>(pcb, <a class="el" href="group__lwip__opts__tcp.html#ga93cce3f47e33df11248c908d1775bacf">TCP_DEFAULT_LISTEN_BACKLOG</a>)</td></tr>
<tr class="separator:ga6b2a4efb1fc15d7d85cb71cb2a1d1066"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga427b11c7b98c748ec487cd43093bd2f8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tcp__raw.html#ga427b11c7b98c748ec487cd43093bd2f8">tcp_backlog_delayed</a> (struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *pcb)</td></tr>
<tr class="separator:ga427b11c7b98c748ec487cd43093bd2f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga619154658137a23839ca3b94882131ca"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tcp__raw.html#ga619154658137a23839ca3b94882131ca">tcp_backlog_accepted</a> (struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *pcb)</td></tr>
<tr class="separator:ga619154658137a23839ca3b94882131ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga87093e137fcc53ea82a134a3f5b33623"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__infrastructure__errors.html#gaf02d9da80fd66b4f986d2c53d7231ddb">err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tcp__raw.html#ga87093e137fcc53ea82a134a3f5b33623">tcp_close</a> (struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *pcb)</td></tr>
<tr class="separator:ga87093e137fcc53ea82a134a3f5b33623"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5b94d57f1891b9287f88525a2ac561dd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__infrastructure__errors.html#gaf02d9da80fd66b4f986d2c53d7231ddb">err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tcp__raw.html#ga5b94d57f1891b9287f88525a2ac561dd">tcp_shutdown</a> (struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *pcb, int shut_rx, int shut_tx)</td></tr>
<tr class="separator:ga5b94d57f1891b9287f88525a2ac561dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga468c2260ddb01582e966ddcf3c25ce61"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tcp__raw.html#ga468c2260ddb01582e966ddcf3c25ce61">tcp_abort</a> (struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *pcb)</td></tr>
<tr class="separator:ga468c2260ddb01582e966ddcf3c25ce61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacf5aa67bd7fc66fef43f77a55a1201ee"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__infrastructure__errors.html#gaf02d9da80fd66b4f986d2c53d7231ddb">err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tcp__raw.html#gacf5aa67bd7fc66fef43f77a55a1201ee">tcp_bind</a> (struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *pcb, const <a class="el" href="group__ipaddr.html#ga16ef96d6cde029029bbf47fee35fd67a">ip_addr_t</a> *ipaddr, u16_t port)</td></tr>
<tr class="separator:gacf5aa67bd7fc66fef43f77a55a1201ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6469a15709088e80024258dbe80fcd1f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tcp__raw.html#ga6469a15709088e80024258dbe80fcd1f">tcp_bind_netif</a> (struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *pcb, const struct <a class="el" href="structnetif.html">netif</a> *<a class="el" href="structnetif.html">netif</a>)</td></tr>
<tr class="separator:ga6469a15709088e80024258dbe80fcd1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeff14f321d1eecd0431611f382fcd338"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tcp__raw.html#gaeff14f321d1eecd0431611f382fcd338">tcp_listen_with_backlog</a> (struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *pcb, u8_t backlog)</td></tr>
<tr class="separator:gaeff14f321d1eecd0431611f382fcd338"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac86ad8ded4d1db15a5b5fb42eb7c1436"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tcp__raw.html#gac86ad8ded4d1db15a5b5fb42eb7c1436">tcp_listen_with_backlog_and_err</a> (struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *pcb, u8_t backlog, <a class="el" href="group__infrastructure__errors.html#gaf02d9da80fd66b4f986d2c53d7231ddb">err_t</a> *err)</td></tr>
<tr class="separator:gac86ad8ded4d1db15a5b5fb42eb7c1436"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabdac0856a52b5789dc897d4c7137ec44"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tcp__raw.html#gabdac0856a52b5789dc897d4c7137ec44">tcp_recved</a> (struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *pcb, u16_t len)</td></tr>
<tr class="separator:gabdac0856a52b5789dc897d4c7137ec44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9a31deea4cadacd39f9485f37cfdd012"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__infrastructure__errors.html#gaf02d9da80fd66b4f986d2c53d7231ddb">err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tcp__raw.html#ga9a31deea4cadacd39f9485f37cfdd012">tcp_connect</a> (struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *pcb, const <a class="el" href="group__ipaddr.html#ga16ef96d6cde029029bbf47fee35fd67a">ip_addr_t</a> *ipaddr, u16_t port, <a class="el" href="tcp_8h.html#a939867106bd492caf2d85852fb7f6ae8">tcp_connected_fn</a> connected)</td></tr>
<tr class="separator:ga9a31deea4cadacd39f9485f37cfdd012"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7427c5d237fe66a8097bfa8d24ceb943"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tcp__raw.html#ga7427c5d237fe66a8097bfa8d24ceb943">tcp_new</a> (void)</td></tr>
<tr class="separator:ga7427c5d237fe66a8097bfa8d24ceb943"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac14e757a21a4a87c6aa52372c210b937"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tcp__raw.html#gac14e757a21a4a87c6aa52372c210b937">tcp_new_ip_type</a> (u8_t type)</td></tr>
<tr class="separator:gac14e757a21a4a87c6aa52372c210b937"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac10926e6f76f73e17c0d37aaab3e56b6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tcp__raw.html#gac10926e6f76f73e17c0d37aaab3e56b6">tcp_arg</a> (struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *pcb, void *arg)</td></tr>
<tr class="separator:gac10926e6f76f73e17c0d37aaab3e56b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8afd0b316a87a5eeff4726dc95006ed0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tcp__raw.html#ga8afd0b316a87a5eeff4726dc95006ed0">tcp_recv</a> (struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *pcb, <a class="el" href="tcp_8h.html#a780cfac08b02c66948ab94ea974202e8">tcp_recv_fn</a> <a class="el" href="group__socket.html#gadd7ae45df7c005619eb1126542231e9b">recv</a>)</td></tr>
<tr class="separator:ga8afd0b316a87a5eeff4726dc95006ed0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1596332b93bb6249179f3b89f24bd808"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tcp__raw.html#ga1596332b93bb6249179f3b89f24bd808">tcp_sent</a> (struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *pcb, <a class="el" href="tcp_8h.html#aa60622ffaa099e97f66fb56e437fca18">tcp_sent_fn</a> sent)</td></tr>
<tr class="separator:ga1596332b93bb6249179f3b89f24bd808"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae1346c4e34d3bc7c01e1b47142ab3121"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tcp__raw.html#gae1346c4e34d3bc7c01e1b47142ab3121">tcp_err</a> (struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *pcb, <a class="el" href="tcp_8h.html#a1b4f9e3551e575c0ef06d6daa7f06e55">tcp_err_fn</a> err)</td></tr>
<tr class="separator:gae1346c4e34d3bc7c01e1b47142ab3121"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaff4c3e380fc60c8fb9b3aa95eda94c62"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tcp__raw.html#gaff4c3e380fc60c8fb9b3aa95eda94c62">tcp_accept</a> (struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *pcb, <a class="el" href="tcp_8h.html#a00517abce6856d6c82f0efebdafb734d">tcp_accept_fn</a> <a class="el" href="group__socket.html#gade2b17671b5a4b18e941fbf7e1060310">accept</a>)</td></tr>
<tr class="separator:gaff4c3e380fc60c8fb9b3aa95eda94c62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafba47015098ed7ce523dcf7bdf70f7e5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tcp__raw.html#gafba47015098ed7ce523dcf7bdf70f7e5">tcp_poll</a> (struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *pcb, <a class="el" href="tcp_8h.html#a66deb97618a9cd9d57fca28c5245e073">tcp_poll_fn</a> <a class="el" href="group__socket.html#ga80ae38841b0e64e60618cd8bf857f617">poll</a>, u8_t interval)</td></tr>
<tr class="separator:gafba47015098ed7ce523dcf7bdf70f7e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6b2aa0efbf10e254930332b7c89cd8c5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__infrastructure__errors.html#gaf02d9da80fd66b4f986d2c53d7231ddb">err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tcp__raw.html#ga6b2aa0efbf10e254930332b7c89cd8c5">tcp_write</a> (struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *pcb, const void *arg, u16_t len, u8_t apiflags)</td></tr>
<tr class="separator:ga6b2aa0efbf10e254930332b7c89cd8c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0cbcc6d628f644a530daf629fa3e5f7f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__infrastructure__errors.html#gaf02d9da80fd66b4f986d2c53d7231ddb">err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tcp__raw.html#ga0cbcc6d628f644a530daf629fa3e5f7f">tcp_output</a> (struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *pcb)</td></tr>
<tr class="separator:ga0cbcc6d628f644a530daf629fa3e5f7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Transmission Control Protocol for IP<br />
</p><dl class="section see"><dt>See also</dt><dd><a class="el" href="group__api.html">APIs</a></dd></dl>
<p>Common functions for the TCP implementation, such as functions for manipulating the data structures and the TCP timer functions. TCP functions related to input and output is found in <a class="el" href="tcp__in_8c.html">tcp_in.c</a> and <a class="el" href="tcp__out_8c.html">tcp_out.c</a> respectively.<br />
 </p><h2>TCP connection setup </h2>
<p>The functions used for setting up connections is similar to that of the sequential API and of the BSD socket API. A new TCP connection identifier (i.e., a protocol control block - PCB) is created with the <a class="el" href="group__tcp__raw.html#ga7427c5d237fe66a8097bfa8d24ceb943">tcp_new()</a> function. This PCB can then be either set to listen for new incoming connections or be explicitly connected to another host.</p><ul>
<li><a class="el" href="group__tcp__raw.html#ga7427c5d237fe66a8097bfa8d24ceb943">tcp_new()</a></li>
<li><a class="el" href="group__tcp__raw.html#gacf5aa67bd7fc66fef43f77a55a1201ee">tcp_bind()</a></li>
<li><a class="el" href="group__tcp__raw.html#ga6b2a4efb1fc15d7d85cb71cb2a1d1066">tcp_listen()</a> and <a class="el" href="group__tcp__raw.html#gaeff14f321d1eecd0431611f382fcd338">tcp_listen_with_backlog()</a></li>
<li><a class="el" href="group__tcp__raw.html#gaff4c3e380fc60c8fb9b3aa95eda94c62">tcp_accept()</a></li>
<li><a class="el" href="group__tcp__raw.html#ga9a31deea4cadacd39f9485f37cfdd012">tcp_connect()</a></li>
</ul>
<h2>Sending TCP data </h2>
<p>TCP data is sent by enqueueing the data with a call to <a class="el" href="group__tcp__raw.html#ga6b2aa0efbf10e254930332b7c89cd8c5">tcp_write()</a> and triggering to send by calling <a class="el" href="group__tcp__raw.html#ga0cbcc6d628f644a530daf629fa3e5f7f">tcp_output()</a>. When the data is successfully transmitted to the remote host, the application will be notified with a call to a specified callback function.</p><ul>
<li><a class="el" href="group__tcp__raw.html#ga6b2aa0efbf10e254930332b7c89cd8c5">tcp_write()</a></li>
<li><a class="el" href="group__tcp__raw.html#ga0cbcc6d628f644a530daf629fa3e5f7f">tcp_output()</a></li>
<li><a class="el" href="group__tcp__raw.html#ga1596332b93bb6249179f3b89f24bd808">tcp_sent()</a></li>
</ul>
<h2>Receiving TCP data </h2>
<p>TCP data reception is callback based - an application specified callback function is called when new data arrives. When the application has taken the data, it has to call the <a class="el" href="group__tcp__raw.html#gabdac0856a52b5789dc897d4c7137ec44">tcp_recved()</a> function to indicate that TCP can advertise increase the receive window.</p><ul>
<li><a class="el" href="group__tcp__raw.html#ga8afd0b316a87a5eeff4726dc95006ed0">tcp_recv()</a></li>
<li><a class="el" href="group__tcp__raw.html#gabdac0856a52b5789dc897d4c7137ec44">tcp_recved()</a></li>
</ul>
<h2>Application polling </h2>
<p>When a connection is idle (i.e., no data is either transmitted or received), lwIP will repeatedly poll the application by calling a specified callback function. This can be used either as a watchdog timer for killing connections that have stayed idle for too long, or as a method of waiting for memory to become available. For instance, if a call to <a class="el" href="group__tcp__raw.html#ga6b2aa0efbf10e254930332b7c89cd8c5">tcp_write()</a> has failed because memory wasn't available, the application may use the polling functionality to call <a class="el" href="group__tcp__raw.html#ga6b2aa0efbf10e254930332b7c89cd8c5">tcp_write()</a> again when the connection has been idle for a while.</p><ul>
<li><a class="el" href="group__tcp__raw.html#gafba47015098ed7ce523dcf7bdf70f7e5">tcp_poll()</a></li>
</ul>
<h2>Closing and aborting connections </h2>
<ul>
<li><a class="el" href="group__tcp__raw.html#ga87093e137fcc53ea82a134a3f5b33623">tcp_close()</a></li>
<li><a class="el" href="group__tcp__raw.html#ga468c2260ddb01582e966ddcf3c25ce61">tcp_abort()</a></li>
<li><a class="el" href="group__tcp__raw.html#gae1346c4e34d3bc7c01e1b47142ab3121">tcp_err()</a> </li>
</ul>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ga6b2a4efb1fc15d7d85cb71cb2a1d1066"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6b2a4efb1fc15d7d85cb71cb2a1d1066">&#9670;&nbsp;</a></span>tcp_listen</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define tcp_listen</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">pcb</td><td>)</td>
          <td>&#160;&#160;&#160;<a class="el" href="group__tcp__raw.html#gaeff14f321d1eecd0431611f382fcd338">tcp_listen_with_backlog</a>(pcb, <a class="el" href="group__lwip__opts__tcp.html#ga93cce3f47e33df11248c908d1775bacf">TCP_DEFAULT_LISTEN_BACKLOG</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="gab0b45a01dcd461e5b8df2a1d9ddda134"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab0b45a01dcd461e5b8df2a1d9ddda134">&#9670;&nbsp;</a></span>tcp_mss</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define tcp_mss</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">pcb</td><td>)</td>
          <td>&#160;&#160;&#160;((pcb)-&gt;mss)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga5b5c0093efff4466bda06d45f12a4633"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5b5c0093efff4466bda06d45f12a4633">&#9670;&nbsp;</a></span>tcp_nagle_disable</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define tcp_nagle_disable</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">pcb</td><td>)</td>
          <td>&#160;&#160;&#160;tcp_set_flags(pcb, TF_NODELAY)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga9398061411b4af900160233aa3b1a286"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9398061411b4af900160233aa3b1a286">&#9670;&nbsp;</a></span>tcp_nagle_disabled</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define tcp_nagle_disabled</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">pcb</td><td>)</td>
          <td>&#160;&#160;&#160;tcp_is_flag_set(pcb, TF_NODELAY)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga9dfcdb8a05533b07dca91cf7e784f88f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9dfcdb8a05533b07dca91cf7e784f88f">&#9670;&nbsp;</a></span>tcp_nagle_enable</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define tcp_nagle_enable</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">pcb</td><td>)</td>
          <td>&#160;&#160;&#160;tcp_clear_flags(pcb, TF_NODELAY)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="gad1a95f09deb49cd7341d35527d6d3e2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad1a95f09deb49cd7341d35527d6d3e2f">&#9670;&nbsp;</a></span>tcp_sndbuf</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define tcp_sndbuf</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">pcb</td><td>)</td>
          <td>&#160;&#160;&#160;(TCPWND16((pcb)-&gt;snd_buf))</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga53ee4364718e84dc42cb1e0179deb1f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga53ee4364718e84dc42cb1e0179deb1f4">&#9670;&nbsp;</a></span>tcp_sndqueuelen</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define tcp_sndqueuelen</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">pcb</td><td>)</td>
          <td>&#160;&#160;&#160;((pcb)-&gt;snd_queuelen)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga468c2260ddb01582e966ddcf3c25ce61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga468c2260ddb01582e966ddcf3c25ce61">&#9670;&nbsp;</a></span>tcp_abort()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tcp_abort </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *&#160;</td>
          <td class="paramname"><em>pcb</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Aborts the connection by sending a RST (reset) segment to the remote host. The pcb is deallocated. This function never fails.</p>
<p>ATTENTION: When calling this from one of the TCP callbacks, make sure you always return ERR_ABRT (and never return ERR_ABRT otherwise or you will risk accessing deallocated memory or memory leaks!</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pcb</td><td>the tcp pcb to abort </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaff4c3e380fc60c8fb9b3aa95eda94c62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaff4c3e380fc60c8fb9b3aa95eda94c62">&#9670;&nbsp;</a></span>tcp_accept()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tcp_accept </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *&#160;</td>
          <td class="paramname"><em>pcb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="tcp_8h.html#a00517abce6856d6c82f0efebdafb734d">tcp_accept_fn</a>&#160;</td>
          <td class="paramname"><em>accept</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Used for specifying the function that should be called when a LISTENing connection has been connected to another host.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pcb</td><td><a class="el" href="structtcp__pcb.html">tcp_pcb</a> to set the accept callback </td></tr>
    <tr><td class="paramname">accept</td><td>callback function to call for this pcb when LISTENing connection has been connected to another host </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gac10926e6f76f73e17c0d37aaab3e56b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac10926e6f76f73e17c0d37aaab3e56b6">&#9670;&nbsp;</a></span>tcp_arg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tcp_arg </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *&#160;</td>
          <td class="paramname"><em>pcb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Specifies the program specific state that should be passed to all other callback functions. The "pcb" argument is the current TCP connection control block, and the "arg" argument is the argument that will be passed to the callbacks.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pcb</td><td><a class="el" href="structtcp__pcb.html">tcp_pcb</a> to set the callback argument </td></tr>
    <tr><td class="paramname">arg</td><td>void pointer argument to pass to callback functions </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga619154658137a23839ca3b94882131ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga619154658137a23839ca3b94882131ca">&#9670;&nbsp;</a></span>tcp_backlog_accepted()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tcp_backlog_accepted </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *&#160;</td>
          <td class="paramname"><em>pcb</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A delayed-accept a connection is accepted (or closed/aborted): decreases the number of outstanding connections after calling <a class="el" href="group__tcp__raw.html#ga427b11c7b98c748ec487cd43093bd2f8">tcp_backlog_delayed()</a>.</p>
<p>ATTENTION: the caller is responsible for calling <a class="el" href="group__tcp__raw.html#ga619154658137a23839ca3b94882131ca">tcp_backlog_accepted()</a> or else the backlog feature will get out of sync!</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pcb</td><td>the connection pcb which is now fully accepted (or closed/aborted) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga427b11c7b98c748ec487cd43093bd2f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga427b11c7b98c748ec487cd43093bd2f8">&#9670;&nbsp;</a></span>tcp_backlog_delayed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tcp_backlog_delayed </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *&#160;</td>
          <td class="paramname"><em>pcb</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Delay accepting a connection in respect to the listen backlog: the number of outstanding connections is increased until <a class="el" href="group__tcp__raw.html#ga619154658137a23839ca3b94882131ca">tcp_backlog_accepted()</a> is called.</p>
<p>ATTENTION: the caller is responsible for calling <a class="el" href="group__tcp__raw.html#ga619154658137a23839ca3b94882131ca">tcp_backlog_accepted()</a> or else the backlog feature will get out of sync!</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pcb</td><td>the connection pcb which is not fully accepted yet </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gacf5aa67bd7fc66fef43f77a55a1201ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacf5aa67bd7fc66fef43f77a55a1201ee">&#9670;&nbsp;</a></span>tcp_bind()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__infrastructure__errors.html#gaf02d9da80fd66b4f986d2c53d7231ddb">err_t</a> tcp_bind </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *&#160;</td>
          <td class="paramname"><em>pcb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__ipaddr.html#ga16ef96d6cde029029bbf47fee35fd67a">ip_addr_t</a> *&#160;</td>
          <td class="paramname"><em>ipaddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u16_t&#160;</td>
          <td class="paramname"><em>port</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Binds the connection to a local port number and IP address. If the IP address is not given (i.e., ipaddr == IP_ANY_TYPE), the connection is bound to all local IP addresses. If another connection is bound to the same port, the function will return ERR_USE, otherwise ERR_OK is returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pcb</td><td>the <a class="el" href="structtcp__pcb.html">tcp_pcb</a> to bind (no check is done whether this pcb is already bound!) </td></tr>
    <tr><td class="paramname">ipaddr</td><td>the local ip address to bind to (use IPx_ADDR_ANY to bind to any local address </td></tr>
    <tr><td class="paramname">port</td><td>the local port to bind to </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ERR_USE if the port is already in use ERR_VAL if bind failed because the PCB is not in a valid state ERR_OK if bound </dd></dl>

</div>
</div>
<a id="ga6469a15709088e80024258dbe80fcd1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6469a15709088e80024258dbe80fcd1f">&#9670;&nbsp;</a></span>tcp_bind_netif()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tcp_bind_netif </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *&#160;</td>
          <td class="paramname"><em>pcb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structnetif.html">netif</a> *&#160;</td>
          <td class="paramname"><em>netif</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Binds the connection to a netif and IP address. After calling this function, all packets received via this PCB are guaranteed to have come in via the specified netif, and all outgoing packets will go out via the specified netif.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pcb</td><td>the <a class="el" href="structtcp__pcb.html">tcp_pcb</a> to bind. </td></tr>
    <tr><td class="paramname">netif</td><td>the netif to bind to. Can be NULL. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga87093e137fcc53ea82a134a3f5b33623"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga87093e137fcc53ea82a134a3f5b33623">&#9670;&nbsp;</a></span>tcp_close()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__infrastructure__errors.html#gaf02d9da80fd66b4f986d2c53d7231ddb">err_t</a> tcp_close </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *&#160;</td>
          <td class="paramname"><em>pcb</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Closes the connection held by the PCB.</p>
<p>Listening pcbs are freed and may not be referenced any more. Connection pcbs are freed if not yet connected and may not be referenced any more. If a connection is established (at least SYN received or in a closing state), the connection is closed, and put in a closing state. The pcb is then automatically freed in <a class="el" href="tcp_8c.html#a421fb42ef919018e14ae413adfee9905">tcp_slowtmr()</a>. It is therefore unsafe to reference it (unless an error is returned).</p>
<p>The function may return ERR_MEM if no memory was available for closing the connection. If so, the application should wait and try again either by using the acknowledgment callback or the polling functionality. If the close succeeds, the function returns ERR_OK.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pcb</td><td>the <a class="el" href="structtcp__pcb.html">tcp_pcb</a> to close </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ERR_OK if connection has been closed another err_t if closing failed and pcb is not freed </dd></dl>

</div>
</div>
<a id="ga9a31deea4cadacd39f9485f37cfdd012"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9a31deea4cadacd39f9485f37cfdd012">&#9670;&nbsp;</a></span>tcp_connect()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__infrastructure__errors.html#gaf02d9da80fd66b4f986d2c53d7231ddb">err_t</a> tcp_connect </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *&#160;</td>
          <td class="paramname"><em>pcb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__ipaddr.html#ga16ef96d6cde029029bbf47fee35fd67a">ip_addr_t</a> *&#160;</td>
          <td class="paramname"><em>ipaddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u16_t&#160;</td>
          <td class="paramname"><em>port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="tcp_8h.html#a939867106bd492caf2d85852fb7f6ae8">tcp_connected_fn</a>&#160;</td>
          <td class="paramname"><em>connected</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Connects to another host. The function given as the "connected" argument will be called when the connection has been established. Sets up the pcb to connect to the remote host and sends the initial SYN segment which opens the connection.</p>
<p>The <a class="el" href="group__tcp__raw.html#ga9a31deea4cadacd39f9485f37cfdd012">tcp_connect()</a> function returns immediately; it does not wait for the connection to be properly setup. Instead, it will call the function specified as the fourth argument (the "connected" argument) when the connection is established. If the connection could not be properly established, either because the other host refused the connection or because the other host didn't answer, the "err" callback function of this pcb (registered with tcp_err, see below) will be called.</p>
<p>The <a class="el" href="group__tcp__raw.html#ga9a31deea4cadacd39f9485f37cfdd012">tcp_connect()</a> function can return ERR_MEM if no memory is available for enqueueing the SYN segment. If the SYN indeed was enqueued successfully, the <a class="el" href="group__tcp__raw.html#ga9a31deea4cadacd39f9485f37cfdd012">tcp_connect()</a> function returns ERR_OK.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pcb</td><td>the <a class="el" href="structtcp__pcb.html">tcp_pcb</a> used to establish the connection </td></tr>
    <tr><td class="paramname">ipaddr</td><td>the remote ip address to connect to </td></tr>
    <tr><td class="paramname">port</td><td>the remote tcp port to connect to </td></tr>
    <tr><td class="paramname">connected</td><td>callback function to call when connected (on error, the err calback will be called) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ERR_VAL if invalid arguments are given ERR_OK if connect request has been sent other err_t values if connect request couldn't be sent </dd></dl>

</div>
</div>
<a id="gae1346c4e34d3bc7c01e1b47142ab3121"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae1346c4e34d3bc7c01e1b47142ab3121">&#9670;&nbsp;</a></span>tcp_err()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tcp_err </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *&#160;</td>
          <td class="paramname"><em>pcb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="tcp_8h.html#a1b4f9e3551e575c0ef06d6daa7f06e55">tcp_err_fn</a>&#160;</td>
          <td class="paramname"><em>err</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Used to specify the function that should be called when a fatal error has occurred on the connection.</p>
<p>If a connection is aborted because of an error, the application is alerted of this event by the err callback. Errors that might abort a connection are when there is a shortage of memory. The callback function to be called is set using the <a class="el" href="group__tcp__raw.html#gae1346c4e34d3bc7c01e1b47142ab3121">tcp_err()</a> function.</p>
<dl class="section note"><dt>Note</dt><dd>The corresponding pcb is already freed when this callback is called!</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pcb</td><td><a class="el" href="structtcp__pcb.html">tcp_pcb</a> to set the err callback </td></tr>
    <tr><td class="paramname">err</td><td>callback function to call for this pcb when a fatal error has occurred on the connection </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaeff14f321d1eecd0431611f382fcd338"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaeff14f321d1eecd0431611f382fcd338">&#9670;&nbsp;</a></span>tcp_listen_with_backlog()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a>* tcp_listen_with_backlog </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *&#160;</td>
          <td class="paramname"><em>pcb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8_t&#160;</td>
          <td class="paramname"><em>backlog</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the state of the connection to be LISTEN, which means that it is able to accept incoming connections. The protocol control block is reallocated in order to consume less memory. Setting the connection to LISTEN is an irreversible process. When an incoming connection is accepted, the function specified with the <a class="el" href="group__tcp__raw.html#gaff4c3e380fc60c8fb9b3aa95eda94c62">tcp_accept()</a> function will be called. The pcb has to be bound to a local port with the <a class="el" href="group__tcp__raw.html#gacf5aa67bd7fc66fef43f77a55a1201ee">tcp_bind()</a> function.</p>
<p>The <a class="el" href="group__tcp__raw.html#ga6b2a4efb1fc15d7d85cb71cb2a1d1066">tcp_listen()</a> function returns a new connection identifier, and the one passed as an argument to the function will be deallocated. The reason for this behavior is that less memory is needed for a connection that is listening, so <a class="el" href="group__tcp__raw.html#ga6b2a4efb1fc15d7d85cb71cb2a1d1066">tcp_listen()</a> will reclaim the memory needed for the original connection and allocate a new smaller memory block for the listening connection.</p>
<p><a class="el" href="group__tcp__raw.html#ga6b2a4efb1fc15d7d85cb71cb2a1d1066">tcp_listen()</a> may return NULL if no memory was available for the listening connection. If so, the memory associated with the pcb passed as an argument to <a class="el" href="group__tcp__raw.html#ga6b2a4efb1fc15d7d85cb71cb2a1d1066">tcp_listen()</a> will not be deallocated.</p>
<p>The backlog limits the number of outstanding connections in the listen queue to the value specified by the backlog argument. To use it, your need to set TCP_LISTEN_BACKLOG=1 in your lwipopts.h.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pcb</td><td>the original <a class="el" href="structtcp__pcb.html">tcp_pcb</a> </td></tr>
    <tr><td class="paramname">backlog</td><td>the incoming connections queue limit </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="structtcp__pcb.html">tcp_pcb</a> used for listening, consumes less memory.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The original <a class="el" href="structtcp__pcb.html">tcp_pcb</a> is freed. This function therefore has to be called like this: tpcb = tcp_listen_with_backlog(tpcb, backlog); </dd></dl>

</div>
</div>
<a id="gac86ad8ded4d1db15a5b5fb42eb7c1436"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac86ad8ded4d1db15a5b5fb42eb7c1436">&#9670;&nbsp;</a></span>tcp_listen_with_backlog_and_err()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a>* tcp_listen_with_backlog_and_err </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *&#160;</td>
          <td class="paramname"><em>pcb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8_t&#160;</td>
          <td class="paramname"><em>backlog</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__infrastructure__errors.html#gaf02d9da80fd66b4f986d2c53d7231ddb">err_t</a> *&#160;</td>
          <td class="paramname"><em>err</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the state of the connection to be LISTEN, which means that it is able to accept incoming connections. The protocol control block is reallocated in order to consume less memory. Setting the connection to LISTEN is an irreversible process.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pcb</td><td>the original <a class="el" href="structtcp__pcb.html">tcp_pcb</a> </td></tr>
    <tr><td class="paramname">backlog</td><td>the incoming connections queue limit </td></tr>
    <tr><td class="paramname">err</td><td>when NULL is returned, this contains the error reason </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="structtcp__pcb.html">tcp_pcb</a> used for listening, consumes less memory.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The original <a class="el" href="structtcp__pcb.html">tcp_pcb</a> is freed. This function therefore has to be called like this: tpcb = tcp_listen_with_backlog_and_err(tpcb, backlog, &amp;err); </dd></dl>

</div>
</div>
<a id="ga7427c5d237fe66a8097bfa8d24ceb943"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7427c5d237fe66a8097bfa8d24ceb943">&#9670;&nbsp;</a></span>tcp_new()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a>* tcp_new </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates a new TCP protocol control block but doesn't place it on any of the TCP PCB lists. The pcb is not put on any list until binding using <a class="el" href="group__tcp__raw.html#gacf5aa67bd7fc66fef43f77a55a1201ee">tcp_bind()</a>. If memory is not available for creating the new pcb, NULL is returned. </p>

</div>
</div>
<a id="gac14e757a21a4a87c6aa52372c210b937"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac14e757a21a4a87c6aa52372c210b937">&#9670;&nbsp;</a></span>tcp_new_ip_type()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a>* tcp_new_ip_type </td>
          <td>(</td>
          <td class="paramtype">u8_t&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates a new TCP protocol control block but doesn't place it on any of the TCP PCB lists. The pcb is not put on any list until binding using <a class="el" href="group__tcp__raw.html#gacf5aa67bd7fc66fef43f77a55a1201ee">tcp_bind()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>IP address type, see <a class="el" href="group__ipaddr.html#gaf2142f0dfdcc938e2db16aa745ed585c">lwip_ip_addr_type</a> definitions. If you want to listen to IPv4 and IPv6 (dual-stack) connections, supply <a class="el" href="group__ipaddr.html#ggaf2142f0dfdcc938e2db16aa745ed585cac6b2c99cf920e08efcb55dc40e42944e">IPADDR_TYPE_ANY</a> as argument and bind to <a class="el" href="group__ipaddr.html#gabe43b154533b73585c4e58f568370ede">IP_ANY_TYPE</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new <a class="el" href="structtcp__pcb.html">tcp_pcb</a> that initially is in state CLOSED </dd></dl>

</div>
</div>
<a id="ga0cbcc6d628f644a530daf629fa3e5f7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0cbcc6d628f644a530daf629fa3e5f7f">&#9670;&nbsp;</a></span>tcp_output()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__infrastructure__errors.html#gaf02d9da80fd66b4f986d2c53d7231ddb">err_t</a> tcp_output </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *&#160;</td>
          <td class="paramname"><em>pcb</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find out what we can send and send it</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pcb</td><td>Protocol control block for the TCP connection to send data </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ERR_OK if data has been sent or nothing to send another err_t on error </dd></dl>

</div>
</div>
<a id="gafba47015098ed7ce523dcf7bdf70f7e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafba47015098ed7ce523dcf7bdf70f7e5">&#9670;&nbsp;</a></span>tcp_poll()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tcp_poll </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *&#160;</td>
          <td class="paramname"><em>pcb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="tcp_8h.html#a66deb97618a9cd9d57fca28c5245e073">tcp_poll_fn</a>&#160;</td>
          <td class="paramname"><em>poll</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8_t&#160;</td>
          <td class="paramname"><em>interval</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Specifies the polling interval and the callback function that should be called to poll the application. The interval is specified in number of TCP coarse grained timer shots, which typically occurs twice a second. An interval of 10 means that the application would be polled every 5 seconds.</p>
<p>When a connection is idle (i.e., no data is either transmitted or received), lwIP will repeatedly poll the application by calling a specified callback function. This can be used either as a watchdog timer for killing connections that have stayed idle for too long, or as a method of waiting for memory to become available. For instance, if a call to <a class="el" href="group__tcp__raw.html#ga6b2aa0efbf10e254930332b7c89cd8c5">tcp_write()</a> has failed because memory wasn't available, the application may use the polling functionality to call <a class="el" href="group__tcp__raw.html#ga6b2aa0efbf10e254930332b7c89cd8c5">tcp_write()</a> again when the connection has been idle for a while. </p>

</div>
</div>
<a id="ga8afd0b316a87a5eeff4726dc95006ed0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8afd0b316a87a5eeff4726dc95006ed0">&#9670;&nbsp;</a></span>tcp_recv()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tcp_recv </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *&#160;</td>
          <td class="paramname"><em>pcb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="tcp_8h.html#a780cfac08b02c66948ab94ea974202e8">tcp_recv_fn</a>&#160;</td>
          <td class="paramname"><em>recv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the callback function that will be called when new data arrives. The callback function will be passed a NULL pbuf to indicate that the remote host has closed the connection. If the callback function returns ERR_OK or ERR_ABRT it must have freed the pbuf, otherwise it must not have freed it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pcb</td><td><a class="el" href="structtcp__pcb.html">tcp_pcb</a> to set the recv callback </td></tr>
    <tr><td class="paramname">recv</td><td>callback function to call for this pcb when data is received </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gabdac0856a52b5789dc897d4c7137ec44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabdac0856a52b5789dc897d4c7137ec44">&#9670;&nbsp;</a></span>tcp_recved()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tcp_recved </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *&#160;</td>
          <td class="paramname"><em>pcb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u16_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function should be called by the application when it has processed the data. The purpose is to advertise a larger window when the data has been processed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pcb</td><td>the <a class="el" href="structtcp__pcb.html">tcp_pcb</a> for which data is read </td></tr>
    <tr><td class="paramname">len</td><td>the amount of bytes that have been read by the application </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga1596332b93bb6249179f3b89f24bd808"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1596332b93bb6249179f3b89f24bd808">&#9670;&nbsp;</a></span>tcp_sent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tcp_sent </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *&#160;</td>
          <td class="paramname"><em>pcb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="tcp_8h.html#aa60622ffaa099e97f66fb56e437fca18">tcp_sent_fn</a>&#160;</td>
          <td class="paramname"><em>sent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Specifies the callback function that should be called when data has successfully been received (i.e., acknowledged) by the remote host. The len argument passed to the callback function gives the amount bytes that was acknowledged by the last acknowledgment.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pcb</td><td><a class="el" href="structtcp__pcb.html">tcp_pcb</a> to set the sent callback </td></tr>
    <tr><td class="paramname">sent</td><td>callback function to call for this pcb when data is successfully sent </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga5b94d57f1891b9287f88525a2ac561dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5b94d57f1891b9287f88525a2ac561dd">&#9670;&nbsp;</a></span>tcp_shutdown()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__infrastructure__errors.html#gaf02d9da80fd66b4f986d2c53d7231ddb">err_t</a> tcp_shutdown </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *&#160;</td>
          <td class="paramname"><em>pcb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>shut_rx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>shut_tx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Causes all or part of a full-duplex connection of this PCB to be shut down. This doesn't deallocate the PCB unless shutting down both sides! Shutting down both sides is the same as calling tcp_close, so if it succeds (i.e. returns ER_OK), the PCB must not be referenced any more!</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pcb</td><td>PCB to shutdown </td></tr>
    <tr><td class="paramname">shut_rx</td><td>shut down receive side if this is != 0 </td></tr>
    <tr><td class="paramname">shut_tx</td><td>shut down send side if this is != 0 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ERR_OK if shutdown succeeded (or the PCB has already been shut down) another err_t on error. </dd></dl>

</div>
</div>
<a id="ga6b2aa0efbf10e254930332b7c89cd8c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6b2aa0efbf10e254930332b7c89cd8c5">&#9670;&nbsp;</a></span>tcp_write()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__infrastructure__errors.html#gaf02d9da80fd66b4f986d2c53d7231ddb">err_t</a> tcp_write </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *&#160;</td>
          <td class="paramname"><em>pcb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u16_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8_t&#160;</td>
          <td class="paramname"><em>apiflags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Write data for sending (but does not send it immediately).</p>
<p>It waits in the expectation of more data being sent soon (as it can send them more efficiently by combining them together). To prompt the system to send data now, call <a class="el" href="group__tcp__raw.html#ga0cbcc6d628f644a530daf629fa3e5f7f">tcp_output()</a> after calling <a class="el" href="group__tcp__raw.html#ga6b2aa0efbf10e254930332b7c89cd8c5">tcp_write()</a>.</p>
<p>This function enqueues the data pointed to by the argument dataptr. The length of the data is passed as the len parameter. The apiflags can be one or more of:</p><ul>
<li>TCP_WRITE_FLAG_COPY: indicates whether the new memory should be allocated for the data to be copied into. If this flag is not given, no new memory should be allocated and the data should only be referenced by pointer. This also means that the memory behind dataptr must not change until the data is ACKed by the remote host</li>
<li>TCP_WRITE_FLAG_MORE: indicates that more data follows. If this is omitted, the PSH flag is set in the last segment created by this call to tcp_write. If this flag is given, the PSH flag is not set.</li>
</ul>
<p>The <a class="el" href="group__tcp__raw.html#ga6b2aa0efbf10e254930332b7c89cd8c5">tcp_write()</a> function will fail and return ERR_MEM if the length of the data exceeds the current send buffer size or if the length of the queue of outgoing segment is larger than the upper limit defined in lwipopts.h. The number of bytes available in the output queue can be retrieved with the <a class="el" href="group__tcp__raw.html#gad1a95f09deb49cd7341d35527d6d3e2f">tcp_sndbuf()</a> function.</p>
<p>The proper way to use this function is to call the function with at most <a class="el" href="group__tcp__raw.html#gad1a95f09deb49cd7341d35527d6d3e2f">tcp_sndbuf()</a> bytes of data. If the function returns ERR_MEM, the application should wait until some of the currently enqueued data has been successfully received by the other host and try again.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pcb</td><td>Protocol control block for the TCP connection to enqueue data for. </td></tr>
    <tr><td class="paramname">arg</td><td>Pointer to the data to be enqueued for sending. </td></tr>
    <tr><td class="paramname">len</td><td>Data length in bytes </td></tr>
    <tr><td class="paramname">apiflags</td><td>combination of following flags :<ul>
<li>TCP_WRITE_FLAG_COPY (0x01) data will be copied into memory belonging to the stack</li>
<li>TCP_WRITE_FLAG_MORE (0x02) for TCP connection, PSH flag will not be set on last segment sent, </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ERR_OK if enqueued, another err_t on error </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
