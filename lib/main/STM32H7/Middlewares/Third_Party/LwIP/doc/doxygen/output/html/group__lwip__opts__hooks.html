<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>lwIP: Hooks</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">lwIP
   &#160;<span id="projectnumber">2.1.2</span>
   </div>
   <div id="projectbrief">Lightweight IP stack</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__lwip__opts__hooks.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a>  </div>
  <div class="headertitle">
<div class="title">Hooks<div class="ingroups"><a class="el" href="group__lwip.html">lwIP</a> &raquo; <a class="el" href="group__lwip__opts.html">Options (lwipopts.h)</a> &raquo; <a class="el" href="group__lwip__opts__infrastructure.html">Infrastructure</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga11ac9d637cb6afc0a32e8da7f51d0c0d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lwip__opts__hooks.html#ga11ac9d637cb6afc0a32e8da7f51d0c0d">LWIP_HOOK_FILENAME</a>&#160;&#160;&#160;&quot;path/to/my/lwip_hooks.h&quot;</td></tr>
<tr class="separator:ga11ac9d637cb6afc0a32e8da7f51d0c0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga078d203053911cf3af178392700386a4"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lwip__opts__hooks.html#ga078d203053911cf3af178392700386a4">LWIP_HOOK_TCP_ISN</a>(local_ip,  local_port,  remote_ip,  remote_port)</td></tr>
<tr class="separator:ga078d203053911cf3af178392700386a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabed8b1cda4aba2d108fa62cdd74895a2"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lwip__opts__hooks.html#gabed8b1cda4aba2d108fa62cdd74895a2">LWIP_HOOK_TCP_INPACKET_PCB</a>(pcb,  hdr,  optlen,  opt1len,  opt2,  p)</td></tr>
<tr class="separator:gabed8b1cda4aba2d108fa62cdd74895a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga31c0694abe4eedf3ff039b7073c2293f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lwip__opts__hooks.html#ga31c0694abe4eedf3ff039b7073c2293f">LWIP_HOOK_TCP_OUT_TCPOPT_LENGTH</a>(pcb,  internal_len)</td></tr>
<tr class="separator:ga31c0694abe4eedf3ff039b7073c2293f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0ef31b749307b63c06633645d4de21f0"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lwip__opts__hooks.html#ga0ef31b749307b63c06633645d4de21f0">LWIP_HOOK_TCP_OUT_ADD_TCPOPTS</a>(p,  hdr,  pcb,  opts)</td></tr>
<tr class="separator:ga0ef31b749307b63c06633645d4de21f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9124237c28e2f18f3b28d5be09e9ccb6"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lwip__opts__hooks.html#ga9124237c28e2f18f3b28d5be09e9ccb6">LWIP_HOOK_IP4_INPUT</a>(<a class="el" href="structpbuf.html">pbuf</a>,  input_netif)</td></tr>
<tr class="separator:ga9124237c28e2f18f3b28d5be09e9ccb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5d1061ad722a73012a28dbaf0f169b70"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lwip__opts__hooks.html#ga5d1061ad722a73012a28dbaf0f169b70">LWIP_HOOK_IP4_ROUTE</a>()</td></tr>
<tr class="separator:ga5d1061ad722a73012a28dbaf0f169b70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa410d9cbe1d4fa4c8a7f49af7b501024"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lwip__opts__hooks.html#gaa410d9cbe1d4fa4c8a7f49af7b501024">LWIP_HOOK_IP4_ROUTE_SRC</a>(src,  dest)</td></tr>
<tr class="separator:gaa410d9cbe1d4fa4c8a7f49af7b501024"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaed848a98dbb5c8856a27e379986ea70d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lwip__opts__hooks.html#gaed848a98dbb5c8856a27e379986ea70d">LWIP_HOOK_IP4_CANFORWARD</a>(src,  dest)</td></tr>
<tr class="separator:gaed848a98dbb5c8856a27e379986ea70d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2b76f127325fd5ca8b80077a4b6160b1"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lwip__opts__hooks.html#ga2b76f127325fd5ca8b80077a4b6160b1">LWIP_HOOK_ETHARP_GET_GW</a>(<a class="el" href="structnetif.html">netif</a>,  dest)</td></tr>
<tr class="separator:ga2b76f127325fd5ca8b80077a4b6160b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaccbdd3d0250f7176dcd799ca06007f20"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lwip__opts__hooks.html#gaccbdd3d0250f7176dcd799ca06007f20">LWIP_HOOK_IP6_INPUT</a>(<a class="el" href="structpbuf.html">pbuf</a>,  input_netif)</td></tr>
<tr class="separator:gaccbdd3d0250f7176dcd799ca06007f20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8245a4bc7ffb172e3bf32276f9d126ce"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lwip__opts__hooks.html#ga8245a4bc7ffb172e3bf32276f9d126ce">LWIP_HOOK_IP6_ROUTE</a>(src,  dest)</td></tr>
<tr class="separator:ga8245a4bc7ffb172e3bf32276f9d126ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga287544c3d74bc2a2d645bddbbc4fbdd0"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lwip__opts__hooks.html#ga287544c3d74bc2a2d645bddbbc4fbdd0">LWIP_HOOK_ND6_GET_GW</a>(<a class="el" href="structnetif.html">netif</a>,  dest)</td></tr>
<tr class="separator:ga287544c3d74bc2a2d645bddbbc4fbdd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2f020543772368f8f4355f50f24c86a9"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lwip__opts__hooks.html#ga2f020543772368f8f4355f50f24c86a9">LWIP_HOOK_VLAN_CHECK</a>(<a class="el" href="structnetif.html">netif</a>,  <a class="el" href="structeth__hdr.html">eth_hdr</a>,  vlan_hdr)</td></tr>
<tr class="separator:ga2f020543772368f8f4355f50f24c86a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2b6e450b4934b95df9b9a9d2b9a4d57e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lwip__opts__hooks.html#ga2b6e450b4934b95df9b9a9d2b9a4d57e">LWIP_HOOK_VLAN_SET</a>(<a class="el" href="structnetif.html">netif</a>,  p,  src,  dst,  eth_type)</td></tr>
<tr class="separator:ga2b6e450b4934b95df9b9a9d2b9a4d57e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga13e90672158221b40f8b12bf9d8b721f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lwip__opts__hooks.html#ga13e90672158221b40f8b12bf9d8b721f">LWIP_HOOK_MEMP_AVAILABLE</a>(memp_t_type)</td></tr>
<tr class="separator:ga13e90672158221b40f8b12bf9d8b721f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6cc92f5101dd7a0420e18e1f2101abf4"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lwip__opts__hooks.html#ga6cc92f5101dd7a0420e18e1f2101abf4">LWIP_HOOK_UNKNOWN_ETH_PROTOCOL</a>(<a class="el" href="structpbuf.html">pbuf</a>,  <a class="el" href="structnetif.html">netif</a>)</td></tr>
<tr class="separator:ga6cc92f5101dd7a0420e18e1f2101abf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga40e6c9aba06e66e5df1b4ca18329f9b4"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lwip__opts__hooks.html#ga40e6c9aba06e66e5df1b4ca18329f9b4">LWIP_HOOK_DHCP_APPEND_OPTIONS</a>(<a class="el" href="structnetif.html">netif</a>,  dhcp,  state,  msg,  msg_type,  options_len_ptr)</td></tr>
<tr class="separator:ga40e6c9aba06e66e5df1b4ca18329f9b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafbbbc574863c0f88988936bd1434f2d2"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lwip__opts__hooks.html#gafbbbc574863c0f88988936bd1434f2d2">LWIP_HOOK_DHCP_PARSE_OPTION</a>(<a class="el" href="structnetif.html">netif</a>,  dhcp,  state,  msg,  msg_type,  option,  len,  <a class="el" href="structpbuf.html">pbuf</a>,  offset)</td></tr>
<tr class="separator:gafbbbc574863c0f88988936bd1434f2d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4068b3313e32f711ba016215fc2c886a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lwip__opts__hooks.html#ga4068b3313e32f711ba016215fc2c886a">LWIP_HOOK_DHCP6_APPEND_OPTIONS</a>(<a class="el" href="structnetif.html">netif</a>,  dhcp6,  state,  msg,  msg_type,  options_len_ptr,  max_len)</td></tr>
<tr class="separator:ga4068b3313e32f711ba016215fc2c886a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga14ea9210c09da4dd33bc85bd8a01b48a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lwip__opts__hooks.html#ga14ea9210c09da4dd33bc85bd8a01b48a">LWIP_HOOK_SOCKETS_SETSOCKOPT</a>(s,  sock,  level,  optname,  optval,  optlen,  err)</td></tr>
<tr class="separator:ga14ea9210c09da4dd33bc85bd8a01b48a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabdaeb09ac9f441934e21a087544a1af1"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lwip__opts__hooks.html#gabdaeb09ac9f441934e21a087544a1af1">LWIP_HOOK_SOCKETS_GETSOCKOPT</a>(s,  sock,  level,  optname,  optval,  optlen,  err)</td></tr>
<tr class="separator:gabdaeb09ac9f441934e21a087544a1af1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae35e4b7374868dc748b12dedb8f807e5"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lwip__opts__hooks.html#gae35e4b7374868dc748b12dedb8f807e5">LWIP_HOOK_NETCONN_EXTERNAL_RESOLVE</a>(name,  addr,  addrtype,  err)</td></tr>
<tr class="separator:gae35e4b7374868dc748b12dedb8f807e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Hooks are undefined by default, define them to a function if you need them. </p>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ga4068b3313e32f711ba016215fc2c886a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4068b3313e32f711ba016215fc2c886a">&#9670;&nbsp;</a></span>LWIP_HOOK_DHCP6_APPEND_OPTIONS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LWIP_HOOK_DHCP6_APPEND_OPTIONS</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><a class="el" href="structnetif.html">netif</a>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">dhcp6, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">state, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">msg, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">msg_type, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">options_len_ptr, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">max_len&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="group__lwip__opts__hooks.html#ga4068b3313e32f711ba016215fc2c886a">LWIP_HOOK_DHCP6_APPEND_OPTIONS(netif, dhcp6, state, msg, msg_type, options_len_ptr, max_len)</a>: Called from various dhcp6 functions when sending a DHCP6 message. This hook is called just before the DHCP6 message is sent, so the options are at the end of a DHCP6 message. Signature:</p><div class="fragment"><div class="line"><span class="keywordtype">void</span> my_hook(<span class="keyword">struct</span> <a class="code" href="structnetif.html">netif</a> *<a class="code" href="structnetif.html">netif</a>, <span class="keyword">struct</span> dhcp6 *dhcp, u8_t <a class="code" href="structnetif.html#a809cc57c0dff09c5c9ae45b02c2002f3">state</a>, <span class="keyword">struct</span> <a class="code" href="structdhcp6__msg.html">dhcp6_msg</a> *msg,</div><div class="line">             u8_t msg_type, u16_t *options_len_ptr);</div></div><!-- fragment --><p> Arguments:</p><ul>
<li>netif: struct netif that the packet will be sent through</li>
<li>dhcp6: struct dhcp6 on that netif</li>
<li>state: current dhcp6 state (dhcp6_state_enum_t as an u8_t)</li>
<li>msg: struct <a class="el" href="structdhcp6__msg.html">dhcp6_msg</a> that will be sent</li>
<li>msg_type: dhcp6 message type to be sent (u8_t)</li>
<li>options_len_ptr: pointer to the current length of options in the <a class="el" href="structdhcp6__msg.html">dhcp6_msg</a> "msg" (must be increased when options are added!)</li>
</ul>
<p>Options need to appended like this: u8_t *options = (u8_t *)(msg + 1); LWIP_ASSERT("dhcp option overflow", sizeof(struct dhcp6_msg) + *options_len_ptr + newoptlen &lt;= max_len); options[(*options_len_ptr)++] = &lt;option_data&gt;; [...] </p>

</div>
</div>
<a id="ga40e6c9aba06e66e5df1b4ca18329f9b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga40e6c9aba06e66e5df1b4ca18329f9b4">&#9670;&nbsp;</a></span>LWIP_HOOK_DHCP_APPEND_OPTIONS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LWIP_HOOK_DHCP_APPEND_OPTIONS</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><a class="el" href="structnetif.html">netif</a>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">dhcp, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">state, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">msg, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">msg_type, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">options_len_ptr&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="group__lwip__opts__hooks.html#ga40e6c9aba06e66e5df1b4ca18329f9b4">LWIP_HOOK_DHCP_APPEND_OPTIONS(netif, dhcp, state, msg, msg_type, options_len_ptr)</a>: Called from various dhcp functions when sending a DHCP message. This hook is called just before the DHCP message trailer is added, so the options are at the end of a DHCP message. Signature:</p><div class="fragment"><div class="line"><span class="keywordtype">void</span> my_hook(<span class="keyword">struct</span> <a class="code" href="structnetif.html">netif</a> *<a class="code" href="structnetif.html">netif</a>, <span class="keyword">struct</span> dhcp *dhcp, u8_t <a class="code" href="structnetif.html#a809cc57c0dff09c5c9ae45b02c2002f3">state</a>, <span class="keyword">struct</span> <a class="code" href="structdhcp__msg.html">dhcp_msg</a> *msg,</div><div class="line">             u8_t msg_type, u16_t *options_len_ptr);</div></div><!-- fragment --><p> Arguments:</p><ul>
<li>netif: struct netif that the packet will be sent through</li>
<li>dhcp: struct dhcp on that netif</li>
<li>state: current dhcp state (dhcp_state_enum_t as an u8_t)</li>
<li>msg: struct <a class="el" href="structdhcp__msg.html">dhcp_msg</a> that will be sent</li>
<li>msg_type: dhcp message type to be sent (u8_t)</li>
<li>options_len_ptr: pointer to the current length of options in the <a class="el" href="structdhcp__msg.html">dhcp_msg</a> "msg" (must be increased when options are added!)</li>
</ul>
<p>Options need to appended like this: LWIP_ASSERT("dhcp option overflow", *options_len_ptr + option_len + 2 &lt;= DHCP_OPTIONS_LEN); msg-&gt;options[(*options_len_ptr)++] = &lt;option_number&gt;; msg-&gt;options[(*options_len_ptr)++] = &lt;option_len&gt;; msg-&gt;options[(*options_len_ptr)++] = &lt;option_bytes&gt;; [...] </p>

</div>
</div>
<a id="gafbbbc574863c0f88988936bd1434f2d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafbbbc574863c0f88988936bd1434f2d2">&#9670;&nbsp;</a></span>LWIP_HOOK_DHCP_PARSE_OPTION</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LWIP_HOOK_DHCP_PARSE_OPTION</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><a class="el" href="structnetif.html">netif</a>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">dhcp, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">state, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">msg, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">msg_type, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">option, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">len, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><a class="el" href="structpbuf.html">pbuf</a>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">offset&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="group__lwip__opts__hooks.html#gafbbbc574863c0f88988936bd1434f2d2">LWIP_HOOK_DHCP_PARSE_OPTION(netif, dhcp, state, msg, msg_type, option, len, pbuf, option_value_offset)</a>: Called from dhcp_parse_reply when receiving a DHCP message. This hook is called for every option in the received message that is not handled internally. Signature:</p><div class="fragment"><div class="line"><span class="keywordtype">void</span> my_hook(<span class="keyword">struct</span> <a class="code" href="structnetif.html">netif</a> *<a class="code" href="structnetif.html">netif</a>, <span class="keyword">struct</span> dhcp *dhcp, u8_t <a class="code" href="structnetif.html#a809cc57c0dff09c5c9ae45b02c2002f3">state</a>, <span class="keyword">struct</span> <a class="code" href="structdhcp__msg.html">dhcp_msg</a> *msg,</div><div class="line">             u8_t msg_type, u8_t option, u8_t option_len, <span class="keyword">struct</span> <a class="code" href="structpbuf.html">pbuf</a> *<a class="code" href="structpbuf.html">pbuf</a>, u16_t option_value_offset);</div></div><!-- fragment --><p> Arguments:</p><ul>
<li>netif: struct netif that the packet will be sent through</li>
<li>dhcp: struct dhcp on that netif</li>
<li>state: current dhcp state (dhcp_state_enum_t as an u8_t)</li>
<li>msg: struct <a class="el" href="structdhcp__msg.html">dhcp_msg</a> that was received</li>
<li>msg_type: dhcp message type received (u8_t, ATTENTION: only valid after the message type option has been parsed!)</li>
<li>option: option value (u8_t)</li>
<li>len: option data length (u8_t)</li>
<li>pbuf: pbuf where option data is contained</li>
<li>option_value_offset: offset in pbuf where option data begins</li>
</ul>
<p>A nice way to get the option contents is <a class="el" href="group__pbuf.html#gad0357ae0be17b2aacd0c301cdc86fc39">pbuf_get_contiguous()</a>: u8_t buf[32]; u8_t <em>ptr = (u8_t</em>)pbuf_get_contiguous(p, buf, sizeof(buf), LWIP_MIN(option_len, sizeof(buf)), offset); </p>

</div>
</div>
<a id="ga2b76f127325fd5ca8b80077a4b6160b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2b76f127325fd5ca8b80077a4b6160b1">&#9670;&nbsp;</a></span>LWIP_HOOK_ETHARP_GET_GW</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LWIP_HOOK_ETHARP_GET_GW</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><a class="el" href="structnetif.html">netif</a>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">dest&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="group__lwip__opts__hooks.html#ga2b76f127325fd5ca8b80077a4b6160b1">LWIP_HOOK_ETHARP_GET_GW(netif, dest)</a>: Called from <a class="el" href="etharp_8c.html#a19258c75a3778b6ed0c82f63a419502d">etharp_output()</a> (IPv4) Signature:</p><div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code" href="structip4__addr.html">ip4_addr_t</a> *my_hook(<span class="keyword">struct</span> <a class="code" href="structnetif.html">netif</a> *<a class="code" href="structnetif.html">netif</a>, <span class="keyword">const</span> <a class="code" href="structip4__addr.html">ip4_addr_t</a> *dest);</div></div><!-- fragment --><p> Arguments:</p><ul>
<li>netif: the netif used for sending</li>
<li>dest: the destination IPv4 address Return values:</li>
<li>the IPv4 address of the gateway to handle the specified destination IPv4 address</li>
<li>NULL, in which case the netif's default gateway is used</li>
</ul>
<p>The returned address MUST be directly reachable on the specified netif! This function is meant to implement advanced IPv4 routing together with <a class="el" href="group__lwip__opts__hooks.html#ga5d1061ad722a73012a28dbaf0f169b70">LWIP_HOOK_IP4_ROUTE()</a>. The actual routing/gateway table implementation is not part of lwIP but can e.g. be hidden in the netif's state argument. </p>

</div>
</div>
<a id="ga11ac9d637cb6afc0a32e8da7f51d0c0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga11ac9d637cb6afc0a32e8da7f51d0c0d">&#9670;&nbsp;</a></span>LWIP_HOOK_FILENAME</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LWIP_HOOK_FILENAME&#160;&#160;&#160;&quot;path/to/my/lwip_hooks.h&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>LWIP_HOOK_FILENAME: Custom filename to #include in files that provide hooks. Declare your hook function prototypes in there, you may also #include all headers providing data types that are need in this file. </p>

</div>
</div>
<a id="gaed848a98dbb5c8856a27e379986ea70d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaed848a98dbb5c8856a27e379986ea70d">&#9670;&nbsp;</a></span>LWIP_HOOK_IP4_CANFORWARD</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LWIP_HOOK_IP4_CANFORWARD</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">src, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">dest&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="group__lwip__opts__hooks.html#gaed848a98dbb5c8856a27e379986ea70d">LWIP_HOOK_IP4_CANFORWARD(src, dest)</a>: Check if an IPv4 can be forwarded - called from: <a class="el" href="ip4_8c.html#aff1f784c9f05f3d79cc1a921d840501b">ip4_input()</a> -&gt; ip4_forward() -&gt; ip4_canforward() (IPv4)</p><ul>
<li>source address is available via <a class="el" href="ip_8h.html#ad2a62f96b9431a79f0258dc13058b160">ip4_current_src_addr()</a></li>
<li>calling an output function in this context (e.g. multicast router) is allowed Signature:<div class="fragment"><div class="line"><span class="keywordtype">int</span> my_hook(<span class="keyword">struct</span> <a class="code" href="structpbuf.html">pbuf</a> *p, u32_t dest_addr_hostorder);</div></div><!-- fragment --> Arguments:</li>
<li>p: packet to forward</li>
<li>dest: destination IPv4 address Returns values:</li>
<li>1: forward</li>
<li>0: don't forward</li>
<li>-1: no decision. In that case, ip4_canforward() continues as normal. </li>
</ul>

</div>
</div>
<a id="ga9124237c28e2f18f3b28d5be09e9ccb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9124237c28e2f18f3b28d5be09e9ccb6">&#9670;&nbsp;</a></span>LWIP_HOOK_IP4_INPUT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LWIP_HOOK_IP4_INPUT</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><a class="el" href="structpbuf.html">pbuf</a>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">input_netif&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="group__lwip__opts__hooks.html#ga9124237c28e2f18f3b28d5be09e9ccb6">LWIP_HOOK_IP4_INPUT(pbuf, input_netif)</a>: Called from <a class="el" href="group__lwip__nosys.html#ga3c420dab0c6760df099a2d688fa42a26">ip_input()</a> (IPv4) Signature:</p><div class="fragment"><div class="line"><span class="keywordtype">int</span> my_hook(<span class="keyword">struct</span> <a class="code" href="structpbuf.html">pbuf</a> *<a class="code" href="structpbuf.html">pbuf</a>, <span class="keyword">struct</span> <a class="code" href="structnetif.html">netif</a> *input_netif);</div></div><!-- fragment --><p> Arguments:</p><ul>
<li>pbuf: received struct pbuf passed to <a class="el" href="group__lwip__nosys.html#ga3c420dab0c6760df099a2d688fa42a26">ip_input()</a></li>
<li>input_netif: struct netif on which the packet has been received Return values:</li>
<li>0: Hook has not consumed the packet, packet is processed as normal</li>
<li>!= 0: Hook has consumed the packet. If the hook consumed the packet, 'pbuf' is in the responsibility of the hook (i.e. free it when done). </li>
</ul>

</div>
</div>
<a id="ga5d1061ad722a73012a28dbaf0f169b70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5d1061ad722a73012a28dbaf0f169b70">&#9670;&nbsp;</a></span>LWIP_HOOK_IP4_ROUTE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LWIP_HOOK_IP4_ROUTE</td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="group__lwip__opts__hooks.html#ga5d1061ad722a73012a28dbaf0f169b70">LWIP_HOOK_IP4_ROUTE(dest)</a>: Called from <a class="el" href="group__ip.html#ga0fa3afc2c00aea346889b476650adee3">ip_route()</a> (IPv4) Signature:</p><div class="fragment"><div class="line"><span class="keyword">struct </span><a class="code" href="structnetif.html">netif</a> *my_hook(<span class="keyword">const</span> <a class="code" href="structip4__addr.html">ip4_addr_t</a> *dest);</div></div><!-- fragment --><p> Arguments:</p><ul>
<li>dest: destination IPv4 address Returns values:</li>
<li>the destination netif</li>
<li>NULL if no destination netif is found. In that case, <a class="el" href="group__ip.html#ga0fa3afc2c00aea346889b476650adee3">ip_route()</a> continues as normal. </li>
</ul>

</div>
</div>
<a id="gaa410d9cbe1d4fa4c8a7f49af7b501024"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa410d9cbe1d4fa4c8a7f49af7b501024">&#9670;&nbsp;</a></span>LWIP_HOOK_IP4_ROUTE_SRC</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LWIP_HOOK_IP4_ROUTE_SRC</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">src, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">dest&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="group__lwip__opts__hooks.html#gaa410d9cbe1d4fa4c8a7f49af7b501024">LWIP_HOOK_IP4_ROUTE_SRC(src, dest)</a>: Source-based routing for IPv4 - called from <a class="el" href="group__ip.html#ga0fa3afc2c00aea346889b476650adee3">ip_route()</a> (IPv4) Signature:</p><div class="fragment"><div class="line"><span class="keyword">struct </span><a class="code" href="structnetif.html">netif</a> *my_hook(<span class="keyword">const</span> <a class="code" href="structip4__addr.html">ip4_addr_t</a> *src, <span class="keyword">const</span> <a class="code" href="structip4__addr.html">ip4_addr_t</a> *dest);</div></div><!-- fragment --><p> Arguments:</p><ul>
<li>src: local/source IPv4 address</li>
<li>dest: destination IPv4 address Returns values:</li>
<li>the destination netif</li>
<li>NULL if no destination netif is found. In that case, <a class="el" href="group__ip.html#ga0fa3afc2c00aea346889b476650adee3">ip_route()</a> continues as normal. </li>
</ul>

</div>
</div>
<a id="gaccbdd3d0250f7176dcd799ca06007f20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaccbdd3d0250f7176dcd799ca06007f20">&#9670;&nbsp;</a></span>LWIP_HOOK_IP6_INPUT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LWIP_HOOK_IP6_INPUT</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><a class="el" href="structpbuf.html">pbuf</a>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">input_netif&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="group__lwip__opts__hooks.html#gaccbdd3d0250f7176dcd799ca06007f20">LWIP_HOOK_IP6_INPUT(pbuf, input_netif)</a>: Called from <a class="el" href="ip6_8c.html#a6bbbae5ea37a82c746dba2feb1abd094">ip6_input()</a> (IPv6) Signature:</p><div class="fragment"><div class="line"><span class="keywordtype">int</span> my_hook(<span class="keyword">struct</span> <a class="code" href="structpbuf.html">pbuf</a> *<a class="code" href="structpbuf.html">pbuf</a>, <span class="keyword">struct</span> <a class="code" href="structnetif.html">netif</a> *input_netif);</div></div><!-- fragment --><p> Arguments:</p><ul>
<li>pbuf: received struct pbuf passed to <a class="el" href="ip6_8c.html#a6bbbae5ea37a82c746dba2feb1abd094">ip6_input()</a></li>
<li>input_netif: struct netif on which the packet has been received Return values:</li>
<li>0: Hook has not consumed the packet, packet is processed as normal</li>
<li>!= 0: Hook has consumed the packet. If the hook consumed the packet, 'pbuf' is in the responsibility of the hook (i.e. free it when done). </li>
</ul>

</div>
</div>
<a id="ga8245a4bc7ffb172e3bf32276f9d126ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8245a4bc7ffb172e3bf32276f9d126ce">&#9670;&nbsp;</a></span>LWIP_HOOK_IP6_ROUTE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LWIP_HOOK_IP6_ROUTE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">src, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">dest&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="group__lwip__opts__hooks.html#ga8245a4bc7ffb172e3bf32276f9d126ce">LWIP_HOOK_IP6_ROUTE(src, dest)</a>: Called from <a class="el" href="group__ip.html#ga0fa3afc2c00aea346889b476650adee3">ip_route()</a> (IPv6) Signature:</p><div class="fragment"><div class="line"><span class="keyword">struct </span><a class="code" href="structnetif.html">netif</a> *my_hook(<span class="keyword">const</span> <a class="code" href="structip6__addr.html">ip6_addr_t</a> *dest, <span class="keyword">const</span> <a class="code" href="structip6__addr.html">ip6_addr_t</a> *src);</div></div><!-- fragment --><p> Arguments:</p><ul>
<li>src: source IPv6 address</li>
<li>dest: destination IPv6 address Return values:</li>
<li>the destination netif</li>
<li>NULL if no destination netif is found. In that case, <a class="el" href="ip6_8c.html#a1153bd9e8c45847282105ab6379e6e70">ip6_route()</a> continues as normal. </li>
</ul>

</div>
</div>
<a id="ga13e90672158221b40f8b12bf9d8b721f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga13e90672158221b40f8b12bf9d8b721f">&#9670;&nbsp;</a></span>LWIP_HOOK_MEMP_AVAILABLE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LWIP_HOOK_MEMP_AVAILABLE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">memp_t_type</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="group__lwip__opts__hooks.html#ga13e90672158221b40f8b12bf9d8b721f">LWIP_HOOK_MEMP_AVAILABLE(memp_t_type)</a>: Called from <a class="el" href="memp_8c.html#aecd94926b7c2a0e23ae195f4ae97581f">memp_free()</a> when a memp pool was empty and an item is now available Signature:</p><div class="fragment"><div class="line"><span class="keywordtype">void</span> my_hook(<a class="code" href="memp_8h.html#a85a164b1f7764951cc685ea525114e57">memp_t</a> type);</div></div><!-- fragment --> 
</div>
</div>
<a id="ga287544c3d74bc2a2d645bddbbc4fbdd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga287544c3d74bc2a2d645bddbbc4fbdd0">&#9670;&nbsp;</a></span>LWIP_HOOK_ND6_GET_GW</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LWIP_HOOK_ND6_GET_GW</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><a class="el" href="structnetif.html">netif</a>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">dest&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="group__lwip__opts__hooks.html#ga287544c3d74bc2a2d645bddbbc4fbdd0">LWIP_HOOK_ND6_GET_GW(netif, dest)</a>: Called from nd6_get_next_hop_entry() (IPv6) Signature:</p><div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code" href="structip6__addr.html">ip6_addr_t</a> *my_hook(<span class="keyword">struct</span> <a class="code" href="structnetif.html">netif</a> *<a class="code" href="structnetif.html">netif</a>, <span class="keyword">const</span> <a class="code" href="structip6__addr.html">ip6_addr_t</a> *dest);</div></div><!-- fragment --><p> Arguments:</p><ul>
<li>netif: the netif used for sending</li>
<li>dest: the destination IPv6 address Return values:</li>
<li>the IPv6 address of the next hop to handle the specified destination IPv6 address</li>
<li>NULL, in which case a NDP-discovered router is used instead</li>
</ul>
<p>The returned address MUST be directly reachable on the specified netif! This function is meant to implement advanced IPv6 routing together with <a class="el" href="group__lwip__opts__hooks.html#ga8245a4bc7ffb172e3bf32276f9d126ce">LWIP_HOOK_IP6_ROUTE()</a>. The actual routing/gateway table implementation is not part of lwIP but can e.g. be hidden in the netif's state argument. </p>

</div>
</div>
<a id="gae35e4b7374868dc748b12dedb8f807e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae35e4b7374868dc748b12dedb8f807e5">&#9670;&nbsp;</a></span>LWIP_HOOK_NETCONN_EXTERNAL_RESOLVE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LWIP_HOOK_NETCONN_EXTERNAL_RESOLVE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">name, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">addr, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">addrtype, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">err&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="group__lwip__opts__hooks.html#gae35e4b7374868dc748b12dedb8f807e5">LWIP_HOOK_NETCONN_EXTERNAL_RESOLVE(name, addr, addrtype, err)</a> Called from netconn APIs (not usable with callback apps) allowing an external DNS resolver (which uses sequential API) to handle the query. Signature:</p><div class="fragment"><div class="line"><span class="keywordtype">int</span> my_hook(<span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="structnetif.html#a32fca6ffd28bb9af3f891a378827a67e">name</a>, <a class="code" href="structip__addr.html">ip_addr_t</a> *addr, u8_t addrtype, <a class="code" href="group__infrastructure__errors.html#gaf02d9da80fd66b4f986d2c53d7231ddb">err_t</a> *err)</div></div><!-- fragment --><p> Arguments:</p><ul>
<li>name: hostname to resolve</li>
<li>addr: output host address</li>
<li>addrtype: type of address to query</li>
<li>err: output error Return values:</li>
<li>0: Hook has not consumed hostname query, query continues into DNS module</li>
<li>!= 0: Hook has consumed the query</li>
</ul>
<p>err must also be checked to determine if the hook consumed the query, but the query failed </p>

</div>
</div>
<a id="gabdaeb09ac9f441934e21a087544a1af1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabdaeb09ac9f441934e21a087544a1af1">&#9670;&nbsp;</a></span>LWIP_HOOK_SOCKETS_GETSOCKOPT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LWIP_HOOK_SOCKETS_GETSOCKOPT</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">s, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">sock, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">level, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">optname, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">optval, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">optlen, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">err&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="group__lwip__opts__hooks.html#gabdaeb09ac9f441934e21a087544a1af1">LWIP_HOOK_SOCKETS_GETSOCKOPT(s, sock, level, optname, optval, optlen, err)</a> Called from socket API to implement <a class="el" href="group__socket.html#gad2de02b35dbbf2334d1befb137ede821">getsockopt()</a> for options not provided by lwIP. Core lock is held when this hook is called. Signature:</p><div class="fragment"><div class="line"><span class="keywordtype">int</span> my_hook(<span class="keywordtype">int</span> s, <span class="keyword">struct</span> <a class="code" href="structlwip__sock.html">lwip_sock</a> *sock, <span class="keywordtype">int</span> level, <span class="keywordtype">int</span> optname, <span class="keywordtype">void</span> *optval, socklen_t *optlen, <span class="keywordtype">int</span> *err)</div></div><!-- fragment --><p> Arguments:</p><ul>
<li>s: socket file descriptor</li>
<li>sock: internal socket descriptor (see <a class="el" href="sockets__priv_8h.html">lwip/priv/sockets_priv.h</a>)</li>
<li>level: protocol level at which the option resides</li>
<li>optname: option to get</li>
<li>optval: value to get</li>
<li>optlen: size of optval</li>
<li>err: output error Return values:</li>
<li>0: Hook has not consumed the option, code continues as normal (to internal options)</li>
<li>!= 0: Hook has consumed the option, 'err' is returned </li>
</ul>

</div>
</div>
<a id="ga14ea9210c09da4dd33bc85bd8a01b48a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga14ea9210c09da4dd33bc85bd8a01b48a">&#9670;&nbsp;</a></span>LWIP_HOOK_SOCKETS_SETSOCKOPT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LWIP_HOOK_SOCKETS_SETSOCKOPT</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">s, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">sock, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">level, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">optname, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">optval, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">optlen, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">err&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="group__lwip__opts__hooks.html#ga14ea9210c09da4dd33bc85bd8a01b48a">LWIP_HOOK_SOCKETS_SETSOCKOPT(s, sock, level, optname, optval, optlen, err)</a> Called from socket API to implement <a class="el" href="group__socket.html#ga115d74cd1953e7bafc2e34157c697df1">setsockopt()</a> for options not provided by lwIP. Core lock is held when this hook is called. Signature:</p><div class="fragment"><div class="line"><span class="keywordtype">int</span> my_hook(<span class="keywordtype">int</span> s, <span class="keyword">struct</span> <a class="code" href="structlwip__sock.html">lwip_sock</a> *sock, <span class="keywordtype">int</span> level, <span class="keywordtype">int</span> optname, <span class="keyword">const</span> <span class="keywordtype">void</span> *optval, socklen_t optlen, <span class="keywordtype">int</span> *err)</div></div><!-- fragment --><p> Arguments:</p><ul>
<li>s: socket file descriptor</li>
<li>sock: internal socket descriptor (see <a class="el" href="sockets__priv_8h.html">lwip/priv/sockets_priv.h</a>)</li>
<li>level: protocol level at which the option resides</li>
<li>optname: option to set</li>
<li>optval: value to set</li>
<li>optlen: size of optval</li>
<li>err: output error Return values:</li>
<li>0: Hook has not consumed the option, code continues as normal (to internal options)</li>
<li>!= 0: Hook has consumed the option, 'err' is returned </li>
</ul>

</div>
</div>
<a id="gabed8b1cda4aba2d108fa62cdd74895a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabed8b1cda4aba2d108fa62cdd74895a2">&#9670;&nbsp;</a></span>LWIP_HOOK_TCP_INPACKET_PCB</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LWIP_HOOK_TCP_INPACKET_PCB</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">pcb, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">hdr, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">optlen, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">opt1len, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">opt2, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">p&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>LWIP_HOOK_TCP_INPACKET_PCB: Hook for intercepting incoming packets before they are passed to a pcb. This allows updating some state or even dropping a packet. Signature:</p><div class="fragment"><div class="line"><a class="code" href="group__infrastructure__errors.html#gaf02d9da80fd66b4f986d2c53d7231ddb">err_t</a> my_hook_tcp_inpkt(<span class="keyword">struct</span> <a class="code" href="structtcp__pcb.html">tcp_pcb</a> *pcb, <span class="keyword">struct</span> tcp_hdr *hdr, u16_t optlen, u16_t opt1len, u8_t *opt2, <span class="keyword">struct</span> <a class="code" href="structpbuf.html">pbuf</a> *p);</div></div><!-- fragment --><p> Arguments:</p><ul>
<li>pcb: <a class="el" href="structtcp__pcb.html">tcp_pcb</a> selected for input of this packet (ATTENTION: this may be struct <a class="el" href="structtcp__pcb__listen.html">tcp_pcb_listen</a> if pcb-&gt;state == LISTEN)</li>
<li>hdr: pointer to tcp header (ATTENTION: tcp options may not be in one piece!)</li>
<li>optlen: tcp option length</li>
<li>opt1len: tcp option length 1st part</li>
<li>opt2: if this is != NULL, tcp options are split among 2 pbufs. In that case, options start at right after the tcp header ('(u8_t*)(hdr + 1)') for the first 'opt1len' bytes and the rest starts at 'opt2'. opt2len can be simply calculated: 'opt2len = optlen - opt1len;'</li>
<li>p: input packet, p-&gt;payload points to application data (that's why tcp hdr and options are passed in seperately) Return value:</li>
<li>ERR_OK: continue input of this packet as normal</li>
<li>!= ERR_OK: drop this packet for input (don't continue input processing)</li>
</ul>
<p>ATTENTION: don't call any tcp api functions that might change tcp state (pcb state or any pcb lists) from this callback! </p>

</div>
</div>
<a id="ga078d203053911cf3af178392700386a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga078d203053911cf3af178392700386a4">&#9670;&nbsp;</a></span>LWIP_HOOK_TCP_ISN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LWIP_HOOK_TCP_ISN</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">local_ip, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">local_port, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">remote_ip, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">remote_port&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>LWIP_HOOK_TCP_ISN: Hook for generation of the Initial Sequence Number (ISN) for a new TCP connection. The default lwIP ISN generation algorithm is very basic and may allow for TCP spoofing attacks. This hook provides the means to implement the standardized ISN generation algorithm from RFC 6528 (see contrib/adons/tcp_isn), or any other desired algorithm as a replacement. Called from <a class="el" href="group__tcp__raw.html#ga9a31deea4cadacd39f9485f37cfdd012">tcp_connect()</a> and tcp_listen_input() when an ISN is needed for a new TCP connection, if TCP support (<a class="el" href="group__lwip__opts__tcp.html#gaa4ed98deb97b77c633cb8870f34c71e9">LWIP_TCP</a>) is enabled.<br />
Signature:</p><div class="fragment"><div class="line">u32_t my_hook_tcp_isn(<span class="keyword">const</span> <a class="code" href="structip__addr.html">ip_addr_t</a>* local_ip, u16_t local_port, <span class="keyword">const</span> <a class="code" href="structip__addr.html">ip_addr_t</a>* remote_ip, u16_t remote_port);</div></div><!-- fragment --><ul>
<li>it may be necessary to use "struct ip_addr" (<a class="el" href="structip4__addr.html">ip4_addr</a>, <a class="el" href="structip6__addr.html">ip6_addr</a>) instead of "ip_addr_t" in function declarations<br />
Arguments:</li>
<li>local_ip: pointer to the local IP address of the connection</li>
<li>local_port: local port number of the connection (host-byte order)</li>
<li>remote_ip: pointer to the remote IP address of the connection</li>
<li>remote_port: remote port number of the connection (host-byte order)<br />
Return value:</li>
<li>the 32-bit Initial Sequence Number to use for the new TCP connection. </li>
</ul>

</div>
</div>
<a id="ga0ef31b749307b63c06633645d4de21f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0ef31b749307b63c06633645d4de21f0">&#9670;&nbsp;</a></span>LWIP_HOOK_TCP_OUT_ADD_TCPOPTS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LWIP_HOOK_TCP_OUT_ADD_TCPOPTS</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">p, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">hdr, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">pcb, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">opts&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>LWIP_HOOK_TCP_OUT_ADD_TCPOPTS: Hook for adding custom options to outgoing tcp segments. Space for these custom options has to be reserved via LWIP_HOOK_TCP_OUT_TCPOPT_LENGTH. Signature:</p><div class="fragment"><div class="line">u32_t *my_hook_tcp_out_add_tcpopts(<span class="keyword">struct</span> <a class="code" href="structpbuf.html">pbuf</a> *p, <span class="keyword">struct</span> tcp_hdr *hdr, <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structtcp__pcb.html">tcp_pcb</a> *pcb, u32_t *opts);</div></div><!-- fragment --><p> Arguments:</p><ul>
<li>p: output packet, p-&gt;payload pointing to tcp header, data follows</li>
<li>hdr: tcp header</li>
<li>pcb: <a class="el" href="structtcp__pcb.html">tcp_pcb</a> that transmits (ATTENTION: this may be NULL or struct <a class="el" href="structtcp__pcb__listen.html">tcp_pcb_listen</a> if pcb-&gt;state == LISTEN)</li>
<li>opts: pointer where to add the custom options (there may already be options between the header and these) Return value:</li>
<li>pointer pointing directly after the inserted options</li>
</ul>
<p>ATTENTION: don't call any tcp api functions that might change tcp state (pcb state or any pcb lists) from this callback! </p>

</div>
</div>
<a id="ga31c0694abe4eedf3ff039b7073c2293f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga31c0694abe4eedf3ff039b7073c2293f">&#9670;&nbsp;</a></span>LWIP_HOOK_TCP_OUT_TCPOPT_LENGTH</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LWIP_HOOK_TCP_OUT_TCPOPT_LENGTH</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">pcb, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">internal_len&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>LWIP_HOOK_TCP_OUT_TCPOPT_LENGTH: Hook for increasing the size of the options allocated with a tcp header. Together with LWIP_HOOK_TCP_OUT_ADD_TCPOPTS, this can be used to add custom options to outgoing tcp segments. Signature:</p><div class="fragment"><div class="line">u8_t my_hook_tcp_out_tcpopt_length(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structtcp__pcb.html">tcp_pcb</a> *pcb, u8_t internal_option_length);</div></div><!-- fragment --><p> Arguments:</p><ul>
<li>pcb: <a class="el" href="structtcp__pcb.html">tcp_pcb</a> that transmits (ATTENTION: this may be NULL or struct <a class="el" href="structtcp__pcb__listen.html">tcp_pcb_listen</a> if pcb-&gt;state == LISTEN)</li>
<li>internal_option_length: tcp option length used by the stack internally Return value:</li>
<li>a number of bytes to allocate for tcp options (internal_option_length &lt;= ret &lt;= 40)</li>
</ul>
<p>ATTENTION: don't call any tcp api functions that might change tcp state (pcb state or any pcb lists) from this callback! </p>

</div>
</div>
<a id="ga6cc92f5101dd7a0420e18e1f2101abf4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6cc92f5101dd7a0420e18e1f2101abf4">&#9670;&nbsp;</a></span>LWIP_HOOK_UNKNOWN_ETH_PROTOCOL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LWIP_HOOK_UNKNOWN_ETH_PROTOCOL</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><a class="el" href="structpbuf.html">pbuf</a>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><a class="el" href="structnetif.html">netif</a>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="group__lwip__opts__hooks.html#ga6cc92f5101dd7a0420e18e1f2101abf4">LWIP_HOOK_UNKNOWN_ETH_PROTOCOL(pbuf, netif)</a>: Called from <a class="el" href="group__lwip__nosys.html#ga6a10c58b82c56d02c48b3cfa2c2494ff">ethernet_input()</a> when an unknown eth type is encountered. Signature:</p><div class="fragment"><div class="line"><a class="code" href="group__infrastructure__errors.html#gaf02d9da80fd66b4f986d2c53d7231ddb">err_t</a> my_hook(<span class="keyword">struct</span> <a class="code" href="structpbuf.html">pbuf</a>* <a class="code" href="structpbuf.html">pbuf</a>, <span class="keyword">struct</span> <a class="code" href="structnetif.html">netif</a>* <a class="code" href="structnetif.html">netif</a>);</div></div><!-- fragment --><p> Arguments:</p><ul>
<li>p: rx packet with unknown eth type</li>
<li>netif: netif on which the packet has been received Return values:</li>
<li>ERR_OK if packet is accepted (hook function now owns the pbuf)</li>
<li>any error code otherwise (pbuf is freed)</li>
</ul>
<p>Payload points to ethernet header! </p>

</div>
</div>
<a id="ga2f020543772368f8f4355f50f24c86a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2f020543772368f8f4355f50f24c86a9">&#9670;&nbsp;</a></span>LWIP_HOOK_VLAN_CHECK</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LWIP_HOOK_VLAN_CHECK</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><a class="el" href="structnetif.html">netif</a>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><a class="el" href="structeth__hdr.html">eth_hdr</a>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">vlan_hdr&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="group__lwip__opts__hooks.html#ga2f020543772368f8f4355f50f24c86a9">LWIP_HOOK_VLAN_CHECK(netif, eth_hdr, vlan_hdr)</a>: Called from <a class="el" href="group__lwip__nosys.html#ga6a10c58b82c56d02c48b3cfa2c2494ff">ethernet_input()</a> if VLAN support is enabled Signature:</p><div class="fragment"><div class="line"><span class="keywordtype">int</span> my_hook(<span class="keyword">struct</span> <a class="code" href="structnetif.html">netif</a> *<a class="code" href="structnetif.html">netif</a>, <span class="keyword">struct</span> <a class="code" href="structeth__hdr.html">eth_hdr</a> *<a class="code" href="structeth__hdr.html">eth_hdr</a>, <span class="keyword">struct</span> <a class="code" href="structeth__vlan__hdr.html">eth_vlan_hdr</a> *vlan_hdr);</div></div><!-- fragment --><p> Arguments:</p><ul>
<li>netif: struct netif on which the packet has been received</li>
<li><a class="el" href="structeth__hdr.html">eth_hdr</a>: struct <a class="el" href="structeth__hdr.html">eth_hdr</a> of the packet</li>
<li>vlan_hdr: struct <a class="el" href="structeth__vlan__hdr.html">eth_vlan_hdr</a> of the packet Return values:</li>
<li>0: Packet must be dropped.</li>
<li>!= 0: Packet must be accepted. </li>
</ul>

</div>
</div>
<a id="ga2b6e450b4934b95df9b9a9d2b9a4d57e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2b6e450b4934b95df9b9a9d2b9a4d57e">&#9670;&nbsp;</a></span>LWIP_HOOK_VLAN_SET</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LWIP_HOOK_VLAN_SET</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><a class="el" href="structnetif.html">netif</a>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">p, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">src, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">dst, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">eth_type&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>LWIP_HOOK_VLAN_SET: Hook can be used to set prio_vid field of vlan_hdr. If you need to store data on per-netif basis to implement this callback, see <a class="el" href="group__netif__cd.html">Client data handling</a>. Called from <a class="el" href="group__ethernet.html#gac9cad5802bfa3d885f13d2ba0f40b778">ethernet_output()</a> if VLAN support (<a class="el" href="group__lwip__opts__arp.html#ga70ce0ecf56cf5fab000134e66d863f90">ETHARP_SUPPORT_VLAN</a>) is enabled.<br />
Signature:</p><div class="fragment"><div class="line">s32_t my_hook_vlan_set(<span class="keyword">struct</span> <a class="code" href="structnetif.html">netif</a>* <a class="code" href="structnetif.html">netif</a>, <span class="keyword">struct</span> <a class="code" href="structpbuf.html">pbuf</a>* <a class="code" href="structpbuf.html">pbuf</a>, <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structeth__addr.html">eth_addr</a>* src, <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structeth__addr.html">eth_addr</a>* dst, u16_t eth_type);\n</div></div><!-- fragment --><p> Arguments:</p><ul>
<li>netif: struct netif that the packet will be sent through</li>
<li>p: struct pbuf packet to be sent</li>
<li>src: source eth address</li>
<li>dst: destination eth address</li>
<li>eth_type: ethernet type to packet to be sent<br />
</li>
</ul>
<p>Return values:</p><ul>
<li>&lt;0: Packet shall not contain VLAN header.</li>
<li>0 &lt;= return value &lt;= 0xFFFF: Packet shall contain VLAN header. Return value is prio_vid in host byte order. </li>
</ul>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
