<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>Storage Interface</title>
<title>CMSIS-Driver: Storage Interface</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="cmsis.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="printComponentTabs.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 46px;">
  <td id="projectlogo"><img alt="Logo" src="CMSIS_Logo_Final.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">CMSIS-Driver
   &#160;<span id="projectnumber">Version 2.7.1</span>
   </div>
   <div id="projectbrief">Peripheral Interface for Middleware and Application Code</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<div id="CMSISnav" class="tabs1">
    <ul class="tablist">
      <script type="text/javascript">
		<!--
		writeComponentTabs.call(this);
		//-->
      </script>
	  </ul>
</div>
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Usage&#160;and&#160;Description</span></a></li>
      <li><a href="modules.html"><span>Reference</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__storage__interface__gr.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#groups">Content</a> &#124;
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Storage Interface</div>  </div>
</div><!--header-->
<div class="contents">

<p>Driver API for Storage Device Interface (Driver_Storage.h)  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="groups"></a>
Content</h2></td></tr>
<tr class="memitem:group__StorageDriverFunctions"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__StorageDriverFunctions.html">Use of Storage APIs</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__SampleUseOfStorageDriver"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SampleUseOfStorageDriver.html">Sample Use of Storage Driver</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:structARM__STORAGE__BLOCK__ATTRIBUTES"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__storage__interface__gr.html#structARM__STORAGE__BLOCK__ATTRIBUTES">ARM_STORAGE_BLOCK_ATTRIBUTES</a></td></tr>
<tr class="memdesc:structARM__STORAGE__BLOCK__ATTRIBUTES"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes of the storage range within a storage block.  <a href="group__storage__interface__gr.html#structARM__STORAGE__BLOCK__ATTRIBUTES">More...</a><br/></td></tr>
<tr class="separator:structARM__STORAGE__BLOCK__ATTRIBUTES"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structARM__STORAGE__BLOCK"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__storage__interface__gr.html#structARM__STORAGE__BLOCK">ARM_STORAGE_BLOCK</a></td></tr>
<tr class="memdesc:structARM__STORAGE__BLOCK"><td class="mdescLeft">&#160;</td><td class="mdescRight">A storage block is a range of memory with uniform attributes.  <a href="group__storage__interface__gr.html#structARM__STORAGE__BLOCK">More...</a><br/></td></tr>
<tr class="separator:structARM__STORAGE__BLOCK"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structARM__STORAGE__INFO"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__storage__interface__gr.html#structARM__STORAGE__INFO">ARM_STORAGE_INFO</a></td></tr>
<tr class="separator:structARM__STORAGE__INFO"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structARM__DRIVER__STORAGE"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__storage__interface__gr.html#structARM__DRIVER__STORAGE">ARM_DRIVER_STORAGE</a></td></tr>
<tr class="separator:structARM__DRIVER__STORAGE"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structARM__STORAGE__CAPABILITIES"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__storage__interface__gr.html#structARM__STORAGE__CAPABILITIES">ARM_STORAGE_CAPABILITIES</a></td></tr>
<tr class="memdesc:structARM__STORAGE__CAPABILITIES"><td class="mdescLeft">&#160;</td><td class="mdescRight">Storage Driver API Capabilities.  <a href="group__storage__interface__gr.html#structARM__STORAGE__CAPABILITIES">More...</a><br/></td></tr>
<tr class="separator:structARM__STORAGE__CAPABILITIES"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structARM__STORAGE__STATUS"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__storage__interface__gr.html#structARM__STORAGE__STATUS">ARM_STORAGE_STATUS</a></td></tr>
<tr class="memdesc:structARM__STORAGE__STATUS"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operating status of the storage controller.  <a href="group__storage__interface__gr.html#structARM__STORAGE__STATUS">More...</a><br/></td></tr>
<tr class="separator:structARM__STORAGE__STATUS"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga4b290224fea782e6d2ad06f541b28a98"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__storage__interface__gr.html#ga4b290224fea782e6d2ad06f541b28a98">ARM_Storage_Callback_t</a> )(int32_t status, <a class="el" href="group__storage__interface__gr.html#ga3a9277f89946d61c41b22da72e3eef7c">ARM_STORAGE_OPERATION</a> operation)</td></tr>
<tr class="separator:ga4b290224fea782e6d2ad06f541b28a98"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga3a9277f89946d61c41b22da72e3eef7c"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__storage__interface__gr.html#ga3a9277f89946d61c41b22da72e3eef7c">ARM_STORAGE_OPERATION</a> { <br/>
&#160;&#160;<a class="el" href="group__storage__interface__gr.html#ga3a9277f89946d61c41b22da72e3eef7cac82e2ca0f9b7ec94e24ae56c45f12f8c">ARM_STORAGE_OPERATION_GET_VERSION</a>, 
<br/>
&#160;&#160;<a class="el" href="group__storage__interface__gr.html#ga3a9277f89946d61c41b22da72e3eef7ca314621ae4384fef7094d8724d59b65c4">ARM_STORAGE_OPERATION_GET_CAPABILITIES</a>, 
<br/>
&#160;&#160;<a class="el" href="group__storage__interface__gr.html#ga3a9277f89946d61c41b22da72e3eef7caca3985b874bf393dc2e448b339668971">ARM_STORAGE_OPERATION_INITIALIZE</a>, 
<br/>
&#160;&#160;<a class="el" href="group__storage__interface__gr.html#ga3a9277f89946d61c41b22da72e3eef7cab9488e567ad58b16c5df2637df3902e9">ARM_STORAGE_OPERATION_UNINITIALIZE</a>, 
<br/>
&#160;&#160;<a class="el" href="group__storage__interface__gr.html#ga3a9277f89946d61c41b22da72e3eef7ca213a74ac5a692a80f17fd6d8e6565e05">ARM_STORAGE_OPERATION_POWER_CONTROL</a>, 
<br/>
&#160;&#160;<a class="el" href="group__storage__interface__gr.html#ga3a9277f89946d61c41b22da72e3eef7ca177812f3cb27c413473d94ebe9480454">ARM_STORAGE_OPERATION_READ_DATA</a>, 
<br/>
&#160;&#160;<a class="el" href="group__storage__interface__gr.html#ga3a9277f89946d61c41b22da72e3eef7ca586b4774a7a092d1932d3415cc42abb0">ARM_STORAGE_OPERATION_PROGRAM_DATA</a>, 
<br/>
&#160;&#160;<a class="el" href="group__storage__interface__gr.html#ga3a9277f89946d61c41b22da72e3eef7cab52a1d10b8087452fd97af8cdb9a6f75">ARM_STORAGE_OPERATION_ERASE</a>, 
<br/>
&#160;&#160;<a class="el" href="group__storage__interface__gr.html#ga3a9277f89946d61c41b22da72e3eef7ca60a0511bd5e32db2a22d3ab2023a601e">ARM_STORAGE_OPERATION_ERASE_ALL</a>, 
<br/>
&#160;&#160;<a class="el" href="group__storage__interface__gr.html#ga3a9277f89946d61c41b22da72e3eef7ca7c595cd3c439753efe0a0b17efd7bb7f">ARM_STORAGE_OPERATION_GET_STATUS</a>, 
<br/>
&#160;&#160;<a class="el" href="group__storage__interface__gr.html#ga3a9277f89946d61c41b22da72e3eef7ca0fe0ef7c0a9e69d053a0419282248f40">ARM_STORAGE_OPERATION_GET_INFO</a>, 
<br/>
&#160;&#160;<a class="el" href="group__storage__interface__gr.html#ga3a9277f89946d61c41b22da72e3eef7ca3292512d0222e4119d0cdf77de1508df">ARM_STORAGE_OPERATION_RESOLVE_ADDRESS</a>, 
<br/>
&#160;&#160;<a class="el" href="group__storage__interface__gr.html#ga3a9277f89946d61c41b22da72e3eef7ca9bfab6ee9caa3ace32338d4ef2d856f5">ARM_STORAGE_OPERATION_GET_NEXT_BLOCK</a>, 
<br/>
&#160;&#160;<a class="el" href="group__storage__interface__gr.html#ga3a9277f89946d61c41b22da72e3eef7cac75096931c3d29af1029f25fc44e7523">ARM_STORAGE_OPERATION_GET_BLOCK</a>
<br/>
 }</td></tr>
<tr class="separator:ga3a9277f89946d61c41b22da72e3eef7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gaf28193431b1a2ee64b22bfb36aed27e3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__common__drv__gr.html#structARM__DRIVER__VERSION">ARM_DRIVER_VERSION</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__storage__interface__gr.html#gaf28193431b1a2ee64b22bfb36aed27e3">ARM_Storage_GetVersion</a> (void)</td></tr>
<tr class="memdesc:gaf28193431b1a2ee64b22bfb36aed27e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get driver version.  <a href="#gaf28193431b1a2ee64b22bfb36aed27e3">More...</a><br/></td></tr>
<tr class="separator:gaf28193431b1a2ee64b22bfb36aed27e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8378b3901dfe76d8f31728a50e10dae2"><td class="memItemLeft" align="right" valign="top">ARM_STOR_CAPABILITIES&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__storage__interface__gr.html#ga8378b3901dfe76d8f31728a50e10dae2">ARM_Storage_GetCapabilities</a> (void)</td></tr>
<tr class="memdesc:ga8378b3901dfe76d8f31728a50e10dae2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get driver capabilities.  <a href="#ga8378b3901dfe76d8f31728a50e10dae2">More...</a><br/></td></tr>
<tr class="separator:ga8378b3901dfe76d8f31728a50e10dae2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacc5dc090a35ac16caff8957030eaa174"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__storage__interface__gr.html#gacc5dc090a35ac16caff8957030eaa174">ARM_Storage_Initialize</a> (<a class="el" href="group__storage__interface__gr.html#ga4b290224fea782e6d2ad06f541b28a98">ARM_Storage_Callback_t</a> callback)</td></tr>
<tr class="memdesc:gacc5dc090a35ac16caff8957030eaa174"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the Storage interface.  <a href="#gacc5dc090a35ac16caff8957030eaa174">More...</a><br/></td></tr>
<tr class="separator:gacc5dc090a35ac16caff8957030eaa174"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1d14b15ddcda2836c6e3c1d0b5e60dca"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__storage__interface__gr.html#ga1d14b15ddcda2836c6e3c1d0b5e60dca">ARM_Storage_Uninitialize</a> (void)</td></tr>
<tr class="memdesc:ga1d14b15ddcda2836c6e3c1d0b5e60dca"><td class="mdescLeft">&#160;</td><td class="mdescRight">De-initialize the Storage Interface.  <a href="#ga1d14b15ddcda2836c6e3c1d0b5e60dca">More...</a><br/></td></tr>
<tr class="separator:ga1d14b15ddcda2836c6e3c1d0b5e60dca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga979a2484bf05b2986de95a5d98307d54"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__storage__interface__gr.html#ga979a2484bf05b2986de95a5d98307d54">ARM_Storage_PowerControl</a> (<a class="el" href="group__common__drv__gr.html#ga47d6d7c31f88f3b8ae4aaf9d8444afa5">ARM_POWER_STATE</a> state)</td></tr>
<tr class="memdesc:ga979a2484bf05b2986de95a5d98307d54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Control the Storage interface power.  <a href="#ga979a2484bf05b2986de95a5d98307d54">More...</a><br/></td></tr>
<tr class="separator:ga979a2484bf05b2986de95a5d98307d54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabaa24553c165add98020434c980b3ab4"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__storage__interface__gr.html#gabaa24553c165add98020434c980b3ab4">ARM_Storage_ReadData</a> (uint64_t addr, void *data, uint32_t size)</td></tr>
<tr class="memdesc:gabaa24553c165add98020434c980b3ab4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read data from Storage.  <a href="#gabaa24553c165add98020434c980b3ab4">More...</a><br/></td></tr>
<tr class="separator:gabaa24553c165add98020434c980b3ab4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabd20d561854c06918b0515b6c1bba230"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__storage__interface__gr.html#gabd20d561854c06918b0515b6c1bba230">ARM_Storage_ProgramData</a> (uint64_t addr, const void *data, uint32_t size)</td></tr>
<tr class="memdesc:gabd20d561854c06918b0515b6c1bba230"><td class="mdescLeft">&#160;</td><td class="mdescRight">Program data to Storage.  <a href="#gabd20d561854c06918b0515b6c1bba230">More...</a><br/></td></tr>
<tr class="separator:gabd20d561854c06918b0515b6c1bba230"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaceef4851d9181cce65c8b2d05f4429bc"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__storage__interface__gr.html#gaceef4851d9181cce65c8b2d05f4429bc">ARM_Storage_Erase</a> (uint64_t addr, uint32_t size)</td></tr>
<tr class="memdesc:gaceef4851d9181cce65c8b2d05f4429bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase Storage range.  <a href="#gaceef4851d9181cce65c8b2d05f4429bc">More...</a><br/></td></tr>
<tr class="separator:gaceef4851d9181cce65c8b2d05f4429bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga04e77387a3c628d6fc661e82f7daddaa"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__storage__interface__gr.html#ga04e77387a3c628d6fc661e82f7daddaa">ARM_Storage_EraseAll</a> (void)</td></tr>
<tr class="memdesc:ga04e77387a3c628d6fc661e82f7daddaa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase complete Storage.  <a href="#ga04e77387a3c628d6fc661e82f7daddaa">More...</a><br/></td></tr>
<tr class="separator:ga04e77387a3c628d6fc661e82f7daddaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga29e7bfe78f41abb16973bdb4e0188a20"><td class="memItemLeft" align="right" valign="top">ARM_Storage_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__storage__interface__gr.html#ga29e7bfe78f41abb16973bdb4e0188a20">ARM_Storage_GetStatus</a> (void)</td></tr>
<tr class="memdesc:ga29e7bfe78f41abb16973bdb4e0188a20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get Storage status.  <a href="#ga29e7bfe78f41abb16973bdb4e0188a20">More...</a><br/></td></tr>
<tr class="separator:ga29e7bfe78f41abb16973bdb4e0188a20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad557e8e6e33cd4528d398ecf4dddc747"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__storage__interface__gr.html#gad557e8e6e33cd4528d398ecf4dddc747">ARM_Storage_GetInfo</a> (<a class="el" href="group__storage__interface__gr.html#structARM__STORAGE__INFO">ARM_STORAGE_INFO</a> *info)</td></tr>
<tr class="memdesc:gad557e8e6e33cd4528d398ecf4dddc747"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get Storage information.  <a href="#gad557e8e6e33cd4528d398ecf4dddc747">More...</a><br/></td></tr>
<tr class="separator:gad557e8e6e33cd4528d398ecf4dddc747"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5a1934750a51c74b8b0fea52588a3b9a"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__storage__interface__gr.html#ga5a1934750a51c74b8b0fea52588a3b9a">ARM_Storage_ResolveAddress</a> (uint64_t addr)</td></tr>
<tr class="memdesc:ga5a1934750a51c74b8b0fea52588a3b9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resolve an address relative to the storage controller into a memory address.  <a href="#ga5a1934750a51c74b8b0fea52588a3b9a">More...</a><br/></td></tr>
<tr class="separator:ga5a1934750a51c74b8b0fea52588a3b9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad318f8cb38626cbeea1fcf36a0977c44"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__storage__interface__gr.html#gad318f8cb38626cbeea1fcf36a0977c44">ARM_Storage_GetNextBlock</a> (const <a class="el" href="group__storage__interface__gr.html#structARM__STORAGE__BLOCK">ARM_STORAGE_BLOCK</a> *prev_block, <a class="el" href="group__storage__interface__gr.html#structARM__STORAGE__BLOCK">ARM_STORAGE_BLOCK</a> *next_block)</td></tr>
<tr class="memdesc:gad318f8cb38626cbeea1fcf36a0977c44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Advance to the successor of the current block (iterator).  <a href="#gad318f8cb38626cbeea1fcf36a0977c44">More...</a><br/></td></tr>
<tr class="separator:gad318f8cb38626cbeea1fcf36a0977c44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5fe9d27ce8afe65124dec62566114073"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__storage__interface__gr.html#ga5fe9d27ce8afe65124dec62566114073">ARM_Storage_GetBlock</a> (uint64_t addr, <a class="el" href="group__storage__interface__gr.html#structARM__STORAGE__BLOCK">ARM_STORAGE_BLOCK</a> *block)</td></tr>
<tr class="memdesc:ga5fe9d27ce8afe65124dec62566114073"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the storage block (iterator) encompassing a given storage address.  <a href="#ga5fe9d27ce8afe65124dec62566114073">More...</a><br/></td></tr>
<tr class="separator:ga5fe9d27ce8afe65124dec62566114073"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Description</h2>
<p>Driver API for Storage Device Interface (Driver_Storage.h) </p>
<p>This is an abstraction for a storage controller. It offers an interface to access an address space of storage locations, comprising APIs for initialization, erase, access, program, and status-fetch operations. It also offers APIs to iterate over the available Storage Blocks (<a class="el" href="group__storage__interface__gr.html#structARM__STORAGE__BLOCK">ARM_STORAGE_BLOCK</a>), allowing the discovery of block attributes such as write/erase granularities. Using the Storage abstraction, it becomes possible to write generic algorithms, such as block copy, to operate on any conforming storage device.</p>
<dl class="section note"><dt>Note</dt><dd>The storage abstraction layer is not responsible for storage management. Algorithms such as block-allocation, wear-leveling, erase-before-write and other storage-management policies are the responsibility of modules external to the storage abstraction layer. In essence, the storage interface is the lowest abstraction upon which block management policies can be implemented.</dd></dl>
<p>Here's a picture to help locate the storage abstraction in the software stack. The part below the box labeled 'Storage abstraction layer' is implemented by a storage driver.</p>
<div class="image">
<img src="storage_sw_stack.png" alt="storage_sw_stack.png"/>
</div>
<p><b>Storage API</b></p>
<p>The following header files define the Application Programming Interface (API) for the Flash interface:</p>
<ul>
<li><b>Driver_Storage.h</b> : Driver API for Storage Device Interface</li>
</ul>
<p><b>Driver Functions</b></p>
<p>The driver functions are published in the access struct as explained in <a class="el" href="group__StorageDriverFunctions.html">Use of Storage APIs</a></p>
<ul>
<li><a class="el" href="group__storage__interface__gr.html#structARM__DRIVER__STORAGE">ARM_DRIVER_STORAGE</a> : access struct for Storage driver functions</li>
</ul>
<p>A sample use for the driver can be found at: <a class="el" href="group__SampleUseOfStorageDriver.html">Sample Use of Storage Driver</a> </p>
<hr/><h2 class="groupheader">Data Structure Documentation</h2>
<a name="structARM__STORAGE__BLOCK__ATTRIBUTES" id="structARM__STORAGE__BLOCK__ATTRIBUTES"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct ARM_STORAGE_BLOCK_ATTRIBUTES</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>Attributes of the storage range within a storage block. </p>
<p><b>Contained in:</b></p>
<ul>
<li><a class="el" href="group__storage__interface__gr.html#structARM__STORAGE__BLOCK">ARM_STORAGE_BLOCK</a> </li>
</ul>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a class="anchor" id="ab350afb2119388ebd3f096bd24f019ef"></a>uint32_t</td>
<td class="fieldname">
erasable: 1</td>
<td class="fielddoc">
Erasing blocks is permitted with a minimum granularity of 'erase_unit'. <dl class="section note"><dt>Note</dt><dd>if 'erasable' is 0 (i.e. the 'erase' operation isn't available) then 'erase_unit' (see below) is immaterial and should be 0. </dd></dl>
</td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="a7f4aebaeeb818b0e2a0592f96559fa1b"></a>uint32_t</td>
<td class="fieldname">
programmable: 1</td>
<td class="fielddoc">
Writing to ranges is permitted with a minimum granularity of 'program_unit'. Writes are typically achieved through the ProgramData operation (following an erase); if storage isn't erasable (see 'erasable' above) but is memory-mapped (i.e. 'memory_mapped'), it can be written directly using memory-store operations. </td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="a910da8e2e909faab1d32cca7f8b05656"></a>uint32_t</td>
<td class="fieldname">
executable: 1</td>
<td class="fielddoc">
This storage block can hold program data; the processor can fetch and execute code sourced from it. Often this is accompanied with the device being 'memory_mapped' (see <a class="el" href="group__storage__interface__gr.html#structARM__STORAGE__INFO">ARM_STORAGE_INFO</a>). </td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="a7c8899f46a471e1b7698a75a759e67c1"></a>uint32_t</td>
<td class="fieldname">
protectable: 1</td>
<td class="fielddoc">
The entire block can be protected from program and erase operations. Once protection is enabled for a block, its 'erasable' and 'programmable' bits are turned off. </td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="aa43c4c21b173ada1b6b7568956f0d650"></a>uint32_t</td>
<td class="fieldname">
reserved: 28</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="aac21d3f798c9fcad415b99cf4157935a"></a>uint32_t</td>
<td class="fieldname">
erase_unit</td>
<td class="fielddoc">
Minimum erase size in bytes. The offset of the start of the erase-range should also be aligned with this value. Applicable if the 'erasable' attribute is set for the block. <dl class="section note"><dt>Note</dt><dd>if 'erasable' (see above) is 0 (i.e. the 'erase' operation isn't available) then 'erase_unit' is immaterial and should be 0. </dd></dl>
</td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="ae319384dfb356cbb0b08ccbf8c04a590"></a>uint32_t</td>
<td class="fieldname">
protection_unit</td>
<td class="fielddoc">
Minimum protectable size in bytes. Applicable if the 'protectable' attribute is set for the block. This should be a divisor of the block's size. A block can be considered to be made up of consecutive, individually-protectable fragments. </td></tr>
</table>

</div>
</div>
<a name="structARM__STORAGE__BLOCK" id="structARM__STORAGE__BLOCK"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct ARM_STORAGE_BLOCK</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>A storage block is a range of memory with uniform attributes. </p>
<p>Storage blocks combine to make up the address map of a storage controller. </p>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a class="anchor" id="a0e89cf6b9f6cd3125470b1bed2b823df"></a>uint64_t</td>
<td class="fieldname">
addr</td>
<td class="fielddoc">
This is the start address of the storage block. It is expressed as an offset from the start of the storage map maintained by the owning storage controller. </td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="af931a8871310b4dad23f0f0b0f623560"></a>uint64_t</td>
<td class="fieldname">
size</td>
<td class="fielddoc">
This is the size of the storage block, in units of bytes. Together with addr, it describes a range [addr, addr+size). </td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="ade62c905888479b4f6d078d45cec5830"></a><a class="el" href="group__storage__interface__gr.html#structARM__STORAGE__BLOCK__ATTRIBUTES">ARM_STORAGE_BLOCK_ATTRIBUTES</a></td>
<td class="fieldname">
attributes</td>
<td class="fielddoc">
Attributes for this block. </td></tr>
</table>

</div>
</div>
<a name="structARM__STORAGE__INFO" id="structARM__STORAGE__INFO"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct ARM_STORAGE_INFO</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>Device level metadata regarding the Storage implementation.</p>
<p>It describes the characteristics of a Storage device. This includes total storage, programming size, a default value for erased memory etc. This information can be obtained from the Storage device datasheet and is used by the middleware in order to properly interact with the Storage device.</p>
<p>Total available storage (in bytes) is contained in <em>total_storage</em>. Minimum programming size (in bytes) is described by <em>program_unit</em> (applicable only if the <em>programmable</em> attribute is set for a block). It defines the granularity for programming data. The offset of the start of a program-range and the size should also be aligned with <em>program_unit</em>. </p>
<dl class="section note"><dt>Note</dt><dd>: setting <em>program_unit</em> to 0 has the effect of disabling the size and alignment restrictions (setting it to 1 also has the same effect).</dd></dl>
<p>Optimal programming page-size (in bytes) is specified by <em>optimal_program_unit</em>. Some storage controllers have internal buffers into which to receive data. Writing in chunks of <em>optimal_program_unit</em> would achieve maximum programming speed. Like with <em>program_unit</em>, this is applicable only if the <em>programmable</em> attribute is set for the underlying storage block(s).</p>
<p><em>program_cycles</em> is a measure of endurance for reprogramming. A value of <em>ARM_STORAGE_PROGRAM_CYCLES_INFINITE</em> may be used to signify infinite or unknown endurance.</p>
<p>Contents of erased memory is specified by the <em>erased_value</em>. It is usually <span class="XML-Token">1</span> to indicate erased bytes with state 0xFF.</p>
<p><em>memory_mapped</em> can be set to <span class="XML-Token">1</span> to indicate that the storage device has a mapping onto the processor's memory address space. </p>
<dl class="section note"><dt>Note</dt><dd>: For a memory-mapped block which isn't erasable but is programmable, writes should be possible directly to the memory-mapped storage without going through the <a class="el" href="group__storage__interface__gr.html#gabd20d561854c06918b0515b6c1bba230">ARM_Storage_ProgramData</a> operation.</dd></dl>
<p>The field <em>programmability</em> holds a value to indicate storage programmability. Similarly, <em>retention_level</em> holds a for encoding data-retention levels for all storage blocks.</p>
<dl class="section note"><dt>Note</dt><dd>These fields serve a different purpose than the ones contained in <a class="el" href="group__storage__interface__gr.html#structARM__STORAGE__CAPABILITIES">ARM_STORAGE_CAPABILITIES</a>, which is another structure containing device-level metadata. <a class="el" href="group__storage__interface__gr.html#structARM__STORAGE__CAPABILITIES" title="Storage Driver API Capabilities. ">ARM_STORAGE_CAPABILITIES</a> describes the API capabilities, whereas <a class="el" href="group__storage__interface__gr.html#structARM__STORAGE__INFO">ARM_STORAGE_INFO</a> describes the device. Furthermore <a class="el" href="group__storage__interface__gr.html#structARM__STORAGE__CAPABILITIES" title="Storage Driver API Capabilities. ">ARM_STORAGE_CAPABILITIES</a> fits within a single word, and is designed to be passed around by value; <a class="el" href="group__storage__interface__gr.html#structARM__STORAGE__INFO">ARM_STORAGE_INFO</a>, on the other hand, contains metadata which doesn't fit into a single word and requires the use of pointers to be moved around.</dd></dl>
<p><b>Returned by:</b></p>
<ul>
<li><a class="el" href="group__storage__interface__gr.html#gad557e8e6e33cd4528d398ecf4dddc747">ARM_Storage_GetInfo</a> </li>
</ul>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a class="anchor" id="a4b14ce1ca2ceea5ce49e81348c5b38f6"></a>uint64_t</td>
<td class="fieldname">
total_storage</td>
<td class="fielddoc">
Total available storage, in bytes. </td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="a483c41066757e2865bf3a27a2a627a54"></a>uint32_t</td>
<td class="fieldname">
program_unit</td>
<td class="fielddoc">
Minimum programming size in bytes. The offset of the start of the program-range should also be aligned with this value. Applicable only if the 'programmable' attribute is set for a block. <dl class="section note"><dt>Note</dt><dd>setting program_unit to 0 has the effect of disabling the size and alignment restrictions (setting it to 1 also has the same effect). </dd></dl>
</td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="a407e16dc7e4da08cea7785efeebd9b6d"></a>uint32_t</td>
<td class="fieldname">
optimal_program_unit</td>
<td class="fielddoc">
Optimal programming page-size in bytes. Some storage controllers have internal buffers into which to receive data. Writing in chunks of 'optimal_program_unit' would achieve maximum programming speed. Applicable only if the 'programmable' attribute is set for the underlying block(s). </td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="ac501623ba5adb4904cdd6c286e7388eb"></a>uint32_t</td>
<td class="fieldname">
program_cycles</td>
<td class="fielddoc">
A measure of endurance for reprogramming. Use ARM_STORAGE_PROGRAM_CYCLES_INFINITE for infinite or unknown endurance. </td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="a902510dbedab116ab6a260a83fbd0f27"></a>uint32_t</td>
<td class="fieldname">
erased_value: 1</td>
<td class="fielddoc">
Contents of erased memory (usually 1 to indicate erased bytes with state 0xFF). </td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="a616b41da466430ed481d791e63784f0c"></a>uint32_t</td>
<td class="fieldname">
memory_mapped: 1</td>
<td class="fielddoc">
This storage device has a mapping onto the processor's memory address space. <dl class="section note"><dt>Note</dt><dd>For a memory-mapped block which isn't erasable but is programmable (i.e. if 'erasable' is set to 0, but 'programmable' is 1), writes should be possible directly to the memory-mapped storage without going through the ProgramData operation. </dd></dl>
</td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="aac0da06bf0775bd9b877aafbc4bcad77"></a>uint32_t</td>
<td class="fieldname">
programmability: 4</td>
<td class="fielddoc">
A value to indicate storage programmability. </td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="a16d1a2aead689ffa28fd89cb6779e5a7"></a>uint32_t</td>
<td class="fieldname">
retention_level: 4</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="aa43c4c21b173ada1b6b7568956f0d650"></a>uint32_t</td>
<td class="fieldname">
reserved: 22</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="aee43dd20848f45fe05efc10a8198817a"></a><a class="el" href="Driver__Storage_8h.html#structARM__STORAGE__SECURITY__FEATURES">ARM_STORAGE_SECURITY_FEATURES</a></td>
<td class="fieldname">
security</td>
<td class="fielddoc">
<a class="el" href="Driver__Storage_8h.html#structARM__STORAGE__SECURITY__FEATURES">ARM_STORAGE_SECURITY_FEATURES</a> </td></tr>
</table>

</div>
</div>
<a name="structARM__DRIVER__STORAGE" id="structARM__DRIVER__STORAGE"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct ARM_DRIVER_STORAGE</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>The set of operations constituting the Storage driver.</p>
<p>This is the set of operations constituting the Storage driver. Their implementation is platform-specific, and needs to be supplied by the porting effort. The functions of the Storage driver are accessed by function pointers exposed by this structure. Refer to <a class="el" href="group__StorageDriverFunctions.html">Use of Storage APIs</a> for overview information.</p>
<p>Each instance of a Storage interface provides such an access structure. The instance is identified by a postfix number in the symbol name of the access structure, for example:</p>
<ul>
<li><b>Driver_Storage0</b> is the name of the access struct of the first instance (no. 0).</li>
<li><b>Driver_Storage1</b> is the name of the access struct of the second instance (no. 1).</li>
</ul>
<p>A middleware configuration setting allows connecting the middleware to a specific driver instance <b>Driver_Flash<em>n</em></b>. The default is <span class="XML-Token">0</span>, which connects a middleware to the first instance of a driver. </p>
</div><table class="memberdecls">
<tr><td colspan="2"><h3>Data Fields</h3></td></tr>
<tr class="memitem:a8834b281da48583845c044a81566c1b3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__common__drv__gr.html#structARM__DRIVER__VERSION">ARM_DRIVER_VERSION</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__storage__interface__gr.html#a8834b281da48583845c044a81566c1b3">GetVersion</a> )(void)</td></tr>
<tr class="memdesc:a8834b281da48583845c044a81566c1b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to <a class="el" href="group__storage__interface__gr.html#gaf28193431b1a2ee64b22bfb36aed27e3">ARM_Storage_GetVersion</a> : Get driver version.  <a href="#a8834b281da48583845c044a81566c1b3">More...</a><br/></td></tr>
<tr class="separator:a8834b281da48583845c044a81566c1b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbfb3aa4b6adb4407de79221bf12cc55"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__storage__interface__gr.html#structARM__STORAGE__CAPABILITIES">ARM_STORAGE_CAPABILITIES</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__storage__interface__gr.html#abbfb3aa4b6adb4407de79221bf12cc55">GetCapabilities</a> )(void)</td></tr>
<tr class="memdesc:abbfb3aa4b6adb4407de79221bf12cc55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to <a class="el" href="group__storage__interface__gr.html#ga8378b3901dfe76d8f31728a50e10dae2">ARM_Storage_GetCapabilities</a> : Get driver capabilities.  <a href="#abbfb3aa4b6adb4407de79221bf12cc55">More...</a><br/></td></tr>
<tr class="separator:abbfb3aa4b6adb4407de79221bf12cc55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a126668a113ce450b0d831c74199b23"><td class="memItemLeft" align="right" valign="top">int32_t(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__storage__interface__gr.html#a4a126668a113ce450b0d831c74199b23">Initialize</a> )(<a class="el" href="group__storage__interface__gr.html#ga4b290224fea782e6d2ad06f541b28a98">ARM_Storage_Callback_t</a> callback)</td></tr>
<tr class="memdesc:a4a126668a113ce450b0d831c74199b23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to <a class="el" href="group__storage__interface__gr.html#gacc5dc090a35ac16caff8957030eaa174">ARM_Storage_Initialize</a> : Initialize the Storage Interface.  <a href="#a4a126668a113ce450b0d831c74199b23">More...</a><br/></td></tr>
<tr class="separator:a4a126668a113ce450b0d831c74199b23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcf20681a1402869ecb5c6447fada17b"><td class="memItemLeft" align="right" valign="top">int32_t(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__storage__interface__gr.html#adcf20681a1402869ecb5c6447fada17b">Uninitialize</a> )(void)</td></tr>
<tr class="memdesc:adcf20681a1402869ecb5c6447fada17b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to <a class="el" href="group__storage__interface__gr.html#ga1d14b15ddcda2836c6e3c1d0b5e60dca">ARM_Storage_Uninitialize</a> : De-initialize the Storage Interface.  <a href="#adcf20681a1402869ecb5c6447fada17b">More...</a><br/></td></tr>
<tr class="separator:adcf20681a1402869ecb5c6447fada17b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba8f1c8019af95ffe19c32403e3240ef"><td class="memItemLeft" align="right" valign="top">int32_t(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__storage__interface__gr.html#aba8f1c8019af95ffe19c32403e3240ef">PowerControl</a> )(<a class="el" href="group__common__drv__gr.html#ga47d6d7c31f88f3b8ae4aaf9d8444afa5">ARM_POWER_STATE</a> state)</td></tr>
<tr class="memdesc:aba8f1c8019af95ffe19c32403e3240ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to <a class="el" href="group__storage__interface__gr.html#ga979a2484bf05b2986de95a5d98307d54">ARM_Storage_PowerControl</a> : Control the Storage interface power.  <a href="#aba8f1c8019af95ffe19c32403e3240ef">More...</a><br/></td></tr>
<tr class="separator:aba8f1c8019af95ffe19c32403e3240ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79b015933daca07a88f98a8f20e1144d"><td class="memItemLeft" align="right" valign="top">int32_t(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__storage__interface__gr.html#a79b015933daca07a88f98a8f20e1144d">ReadData</a> )(uint64_t addr, void *data, uint32_t size)</td></tr>
<tr class="memdesc:a79b015933daca07a88f98a8f20e1144d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to <a class="el" href="group__storage__interface__gr.html#gabaa24553c165add98020434c980b3ab4">ARM_Storage_ReadData</a> : Read data from Storage.  <a href="#a79b015933daca07a88f98a8f20e1144d">More...</a><br/></td></tr>
<tr class="separator:a79b015933daca07a88f98a8f20e1144d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedda6cc77ea7c4ef2356c683f9013d8b"><td class="memItemLeft" align="right" valign="top">int32_t(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__storage__interface__gr.html#aedda6cc77ea7c4ef2356c683f9013d8b">ProgramData</a> )(uint64_t addr, const void *data, uint32_t size)</td></tr>
<tr class="memdesc:aedda6cc77ea7c4ef2356c683f9013d8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to <a class="el" href="group__storage__interface__gr.html#gabd20d561854c06918b0515b6c1bba230">ARM_Storage_ProgramData</a> : Program data to Storage.  <a href="#aedda6cc77ea7c4ef2356c683f9013d8b">More...</a><br/></td></tr>
<tr class="separator:aedda6cc77ea7c4ef2356c683f9013d8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb5018d1afb3ea4632e6e6006314f37f"><td class="memItemLeft" align="right" valign="top">int32_t(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__storage__interface__gr.html#abb5018d1afb3ea4632e6e6006314f37f">Erase</a> )(uint64_t addr, uint32_t size)</td></tr>
<tr class="memdesc:abb5018d1afb3ea4632e6e6006314f37f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to <a class="el" href="group__storage__interface__gr.html#gaceef4851d9181cce65c8b2d05f4429bc">ARM_Storage_Erase</a> : Erase Storage range.  <a href="#abb5018d1afb3ea4632e6e6006314f37f">More...</a><br/></td></tr>
<tr class="separator:abb5018d1afb3ea4632e6e6006314f37f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4dc5af362c0f2043138618aea9c6a73"><td class="memItemLeft" align="right" valign="top">int32_t(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__storage__interface__gr.html#ad4dc5af362c0f2043138618aea9c6a73">EraseAll</a> )(void)</td></tr>
<tr class="memdesc:ad4dc5af362c0f2043138618aea9c6a73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to <a class="el" href="group__storage__interface__gr.html#ga04e77387a3c628d6fc661e82f7daddaa">ARM_Storage_EraseAll</a> : Erase complete Storage.  <a href="#ad4dc5af362c0f2043138618aea9c6a73">More...</a><br/></td></tr>
<tr class="separator:ad4dc5af362c0f2043138618aea9c6a73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a820e9b9de75ebe93e64b067468b369af"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__storage__interface__gr.html#structARM__STORAGE__STATUS">ARM_STORAGE_STATUS</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__storage__interface__gr.html#a820e9b9de75ebe93e64b067468b369af">GetStatus</a> )(void)</td></tr>
<tr class="memdesc:a820e9b9de75ebe93e64b067468b369af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to <a class="el" href="group__storage__interface__gr.html#ga29e7bfe78f41abb16973bdb4e0188a20">ARM_Storage_GetStatus</a> : Get Storage status.  <a href="#a820e9b9de75ebe93e64b067468b369af">More...</a><br/></td></tr>
<tr class="separator:a820e9b9de75ebe93e64b067468b369af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec80a5d1ccf1cd996f6e863ac8868d65"><td class="memItemLeft" align="right" valign="top">int32_t(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__storage__interface__gr.html#aec80a5d1ccf1cd996f6e863ac8868d65">GetInfo</a> )(<a class="el" href="group__storage__interface__gr.html#structARM__STORAGE__INFO">ARM_STORAGE_INFO</a> *info)</td></tr>
<tr class="memdesc:aec80a5d1ccf1cd996f6e863ac8868d65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to <a class="el" href="group__storage__interface__gr.html#gad557e8e6e33cd4528d398ecf4dddc747">ARM_Storage_GetInfo</a> : Get Storage information.  <a href="#aec80a5d1ccf1cd996f6e863ac8868d65">More...</a><br/></td></tr>
<tr class="separator:aec80a5d1ccf1cd996f6e863ac8868d65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e1b3f9abb40bb5c70c6141587ee6e6a"><td class="memItemLeft" align="right" valign="top">uint32_t(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__storage__interface__gr.html#a6e1b3f9abb40bb5c70c6141587ee6e6a">ResolveAddress</a> )(uint64_t addr)</td></tr>
<tr class="memdesc:a6e1b3f9abb40bb5c70c6141587ee6e6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to <a class="el" href="group__storage__interface__gr.html#ga5a1934750a51c74b8b0fea52588a3b9a">ARM_Storage_ResolveAddress</a> : Resolve a storage address.  <a href="#a6e1b3f9abb40bb5c70c6141587ee6e6a">More...</a><br/></td></tr>
<tr class="separator:a6e1b3f9abb40bb5c70c6141587ee6e6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adda93f4d74519247517f036c4551dd13"><td class="memItemLeft" align="right" valign="top">int32_t(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__storage__interface__gr.html#adda93f4d74519247517f036c4551dd13">GetNextBlock</a> )(const <a class="el" href="group__storage__interface__gr.html#structARM__STORAGE__BLOCK">ARM_STORAGE_BLOCK</a> *prev, <a class="el" href="group__storage__interface__gr.html#structARM__STORAGE__BLOCK">ARM_STORAGE_BLOCK</a> *next)</td></tr>
<tr class="memdesc:adda93f4d74519247517f036c4551dd13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to <a class="el" href="group__storage__interface__gr.html#gad318f8cb38626cbeea1fcf36a0977c44">ARM_Storage_GetNextBlock</a> : fetch successor for current block.  <a href="#adda93f4d74519247517f036c4551dd13">More...</a><br/></td></tr>
<tr class="separator:adda93f4d74519247517f036c4551dd13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af43edebfb5463d22ffeda6de20e1d1bd"><td class="memItemLeft" align="right" valign="top">int32_t(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__storage__interface__gr.html#af43edebfb5463d22ffeda6de20e1d1bd">GetBlock</a> )(uint64_t addr, <a class="el" href="group__storage__interface__gr.html#structARM__STORAGE__BLOCK">ARM_STORAGE_BLOCK</a> *block)</td></tr>
<tr class="memdesc:af43edebfb5463d22ffeda6de20e1d1bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to <a class="el" href="group__storage__interface__gr.html#ga5fe9d27ce8afe65124dec62566114073">ARM_Storage_GetBlock</a> :  <a href="#af43edebfb5463d22ffeda6de20e1d1bd">More...</a><br/></td></tr>
<tr class="separator:af43edebfb5463d22ffeda6de20e1d1bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h4 class="groupheader">Field Documentation</h4>
<a class="anchor" id="a8834b281da48583845c044a81566c1b3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__common__drv__gr.html#structARM__DRIVER__VERSION">ARM_DRIVER_VERSION</a>(* GetVersion)(void)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pointer to <a class="el" href="group__storage__interface__gr.html#gaf28193431b1a2ee64b22bfb36aed27e3">ARM_Storage_GetVersion</a> : Get driver version. </p>

</div>
</div>
<a class="anchor" id="abbfb3aa4b6adb4407de79221bf12cc55"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__storage__interface__gr.html#structARM__STORAGE__CAPABILITIES">ARM_STORAGE_CAPABILITIES</a>(* GetCapabilities)(void)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pointer to <a class="el" href="group__storage__interface__gr.html#ga8378b3901dfe76d8f31728a50e10dae2">ARM_Storage_GetCapabilities</a> : Get driver capabilities. </p>

</div>
</div>
<a class="anchor" id="a4a126668a113ce450b0d831c74199b23"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t(* Initialize)(<a class="el" href="group__storage__interface__gr.html#ga4b290224fea782e6d2ad06f541b28a98">ARM_Storage_Callback_t</a> callback)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pointer to <a class="el" href="group__storage__interface__gr.html#gacc5dc090a35ac16caff8957030eaa174">ARM_Storage_Initialize</a> : Initialize the Storage Interface. </p>

</div>
</div>
<a class="anchor" id="adcf20681a1402869ecb5c6447fada17b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t(* Uninitialize)(void)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pointer to <a class="el" href="group__storage__interface__gr.html#ga1d14b15ddcda2836c6e3c1d0b5e60dca">ARM_Storage_Uninitialize</a> : De-initialize the Storage Interface. </p>

</div>
</div>
<a class="anchor" id="aba8f1c8019af95ffe19c32403e3240ef"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t(* PowerControl)(<a class="el" href="group__common__drv__gr.html#ga47d6d7c31f88f3b8ae4aaf9d8444afa5">ARM_POWER_STATE</a> state)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pointer to <a class="el" href="group__storage__interface__gr.html#ga979a2484bf05b2986de95a5d98307d54">ARM_Storage_PowerControl</a> : Control the Storage interface power. </p>

</div>
</div>
<a class="anchor" id="a79b015933daca07a88f98a8f20e1144d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t(* ReadData)(uint64_t addr, void *data, uint32_t size)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pointer to <a class="el" href="group__storage__interface__gr.html#gabaa24553c165add98020434c980b3ab4">ARM_Storage_ReadData</a> : Read data from Storage. </p>

</div>
</div>
<a class="anchor" id="aedda6cc77ea7c4ef2356c683f9013d8b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t(* ProgramData)(uint64_t addr, const void *data, uint32_t size)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pointer to <a class="el" href="group__storage__interface__gr.html#gabd20d561854c06918b0515b6c1bba230">ARM_Storage_ProgramData</a> : Program data to Storage. </p>

</div>
</div>
<a class="anchor" id="abb5018d1afb3ea4632e6e6006314f37f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t(* Erase)(uint64_t addr, uint32_t size)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pointer to <a class="el" href="group__storage__interface__gr.html#gaceef4851d9181cce65c8b2d05f4429bc">ARM_Storage_Erase</a> : Erase Storage range. </p>

</div>
</div>
<a class="anchor" id="ad4dc5af362c0f2043138618aea9c6a73"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t(* EraseAll)(void)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pointer to <a class="el" href="group__storage__interface__gr.html#ga04e77387a3c628d6fc661e82f7daddaa">ARM_Storage_EraseAll</a> : Erase complete Storage. </p>

</div>
</div>
<a class="anchor" id="a820e9b9de75ebe93e64b067468b369af"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__storage__interface__gr.html#structARM__STORAGE__STATUS">ARM_STORAGE_STATUS</a>(* GetStatus)(void)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pointer to <a class="el" href="group__storage__interface__gr.html#ga29e7bfe78f41abb16973bdb4e0188a20">ARM_Storage_GetStatus</a> : Get Storage status. </p>

</div>
</div>
<a class="anchor" id="aec80a5d1ccf1cd996f6e863ac8868d65"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t(* GetInfo)(<a class="el" href="group__storage__interface__gr.html#structARM__STORAGE__INFO">ARM_STORAGE_INFO</a> *info)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pointer to <a class="el" href="group__storage__interface__gr.html#gad557e8e6e33cd4528d398ecf4dddc747">ARM_Storage_GetInfo</a> : Get Storage information. </p>

</div>
</div>
<a class="anchor" id="a6e1b3f9abb40bb5c70c6141587ee6e6a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t(* ResolveAddress)(uint64_t addr)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pointer to <a class="el" href="group__storage__interface__gr.html#ga5a1934750a51c74b8b0fea52588a3b9a">ARM_Storage_ResolveAddress</a> : Resolve a storage address. </p>

</div>
</div>
<a class="anchor" id="adda93f4d74519247517f036c4551dd13"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t(* GetNextBlock)(const <a class="el" href="group__storage__interface__gr.html#structARM__STORAGE__BLOCK">ARM_STORAGE_BLOCK</a> *prev, <a class="el" href="group__storage__interface__gr.html#structARM__STORAGE__BLOCK">ARM_STORAGE_BLOCK</a> *next)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pointer to <a class="el" href="group__storage__interface__gr.html#gad318f8cb38626cbeea1fcf36a0977c44">ARM_Storage_GetNextBlock</a> : fetch successor for current block. </p>

</div>
</div>
<a class="anchor" id="af43edebfb5463d22ffeda6de20e1d1bd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t(* GetBlock)(uint64_t addr, <a class="el" href="group__storage__interface__gr.html#structARM__STORAGE__BLOCK">ARM_STORAGE_BLOCK</a> *block)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pointer to <a class="el" href="group__storage__interface__gr.html#ga5fe9d27ce8afe65124dec62566114073">ARM_Storage_GetBlock</a> : </p>

</div>
</div>

</div>
</div>
<a name="structARM__STORAGE__CAPABILITIES" id="structARM__STORAGE__CAPABILITIES"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct ARM_STORAGE_CAPABILITIES</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>Storage Driver API Capabilities. </p>
<p>A Storage driver can be implemented with different capabilities. The data fields of this struct encode the API capabilities implemented by this driver.</p>
<p>The element <em>asynchronous_ops</em> indicates if APIs like initialize, read, erase, program, etc. can operate in asynchronous mode. Having this bit set to 1 means that the driver is capable of launching asynchronous operations; command completion for asynchronous operations is signaled by the invocation of a completion callback. If set to 1, drivers may still complete asynchronous operations synchronously as necessary&ndash;in which case they return a positive error code to indicate synchronous completion. If <em>asynchronous_ops</em> is not set, then all such APIs execute synchronously, and control returns to the caller with a status code only after the completion of the operation (or the discovery of a failure condition).</p>
<p>The element <em>erase_all</em> specifies that the <a class="el" href="group__storage__interface__gr.html#ga04e77387a3c628d6fc661e82f7daddaa">ARM_Storage_EraseAll</a> function is supported. Typically full chip erase is much faster than erasing the whole device using <em>ARM_Storage_Erase</em>.</p>
<p><b>Returned by:</b></p>
<ul>
<li><a class="el" href="group__storage__interface__gr.html#ga8378b3901dfe76d8f31728a50e10dae2">ARM_Storage_GetCapabilities</a></li>
</ul>
<dl class="section note"><dt>Note</dt><dd>This data structure is designed to fit within a single word so that it can be fetched cheaply using a call to driver-&gt;GetCapabilities(). </dd></dl>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a class="anchor" id="a15ade4ca762bc6ce72d435a16febb4cc"></a>uint32_t</td>
<td class="fieldname">
asynchronous_ops: 1</td>
<td class="fielddoc">
Used to indicate if APIs like initialize, read, erase, program, etc. can operate in asynchronous mode. Setting this bit to 1 means that the driver is capable of launching asynchronous operations; command completion is signaled by the invocation of a completion callback. If set to 1, drivers may still complete asynchronous operations synchronously as necessary (in which case they return a positive error code to indicate synchronous completion). </td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="a63882f6a571f20aad1b5b3542cdaafa1"></a>uint32_t</td>
<td class="fieldname">
erase_all: 1</td>
<td class="fielddoc">
Supports EraseAll operation. </td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="aa43c4c21b173ada1b6b7568956f0d650"></a>uint32_t</td>
<td class="fieldname">
reserved: 30</td>
<td class="fielddoc">
Reserved (must be zero) </td></tr>
</table>

</div>
</div>
<a name="structARM__STORAGE__STATUS" id="structARM__STORAGE__STATUS"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct ARM_STORAGE_STATUS</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>Operating status of the storage controller. </p>
<p>Structure with information about the status of the Storage device.</p>
<p>The flag <em>busy</em> indicates that the driver is busy executing read/program/erase operation.</p>
<p>The flag <em>error</em> flag is cleared on start of read/program/erase operation and is set at the end of the current operation in case of error.</p>
<p><b>Returned by:</b></p>
<ul>
<li><a class="el" href="group__storage__interface__gr.html#ga29e7bfe78f41abb16973bdb4e0188a20">ARM_Storage_GetStatus</a> </li>
</ul>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a class="anchor" id="a50c88f3c1d787773e2ac1b59533f034a"></a>uint32_t</td>
<td class="fieldname">
busy: 1</td>
<td class="fielddoc">
Controller busy flag. </td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="aa8d183302fdfa4a6892f1d80300cdb32"></a>uint32_t</td>
<td class="fieldname">
error: 1</td>
<td class="fielddoc">
Read/Program/Erase error flag (cleared on start of next operation) </td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="aa43c4c21b173ada1b6b7568956f0d650"></a>uint32_t</td>
<td class="fieldname">
reserved: 30</td>
<td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="ga4b290224fea782e6d2ad06f541b28a98"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ARM_Storage_Callback_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Provides the typedef for the callback function <a class="el" href="group__storage__interface__gr.html#ga4b290224fea782e6d2ad06f541b28a98">ARM_Storage_Callback_t</a>.</p>
<p>Provides the typedef for the callback function <a class="el" href="group__storage__interface__gr.html#ga4b290224fea782e6d2ad06f541b28a98">ARM_Storage_Callback_t</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">status</td><td>A code to indicate the status of the completed operation. For data transfer operations, the status field is overloaded in case of success to return the count of bytes successfully transferred; this can be done safely because error codes are negative values.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">operation</td><td>The command op-code. This value isn't essential, but it is expected that this information could be a quick and useful filter for the handler.</td></tr>
  </table>
  </dd>
</dl>
<p><b>Parameter for:</b></p>
<ul>
<li><a class="el" href="group__storage__interface__gr.html#gacc5dc090a35ac16caff8957030eaa174">ARM_Storage_Initialize</a> </li>
</ul>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a class="anchor" id="ga3a9277f89946d61c41b22da72e3eef7c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__storage__interface__gr.html#ga3a9277f89946d61c41b22da72e3eef7c">ARM_STORAGE_OPERATION</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Command opcodes for Storage.</p>
<p>Command opcodes for the Storage interface. Completion callbacks use these codes to refer to completing commands. Refer to <a class="el" href="group__storage__interface__gr.html#ga4b290224fea782e6d2ad06f541b28a98">ARM_Storage_Callback_t</a>. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="ga3a9277f89946d61c41b22da72e3eef7cac82e2ca0f9b7ec94e24ae56c45f12f8c"></a>ARM_STORAGE_OPERATION_GET_VERSION</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ga3a9277f89946d61c41b22da72e3eef7ca314621ae4384fef7094d8724d59b65c4"></a>ARM_STORAGE_OPERATION_GET_CAPABILITIES</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ga3a9277f89946d61c41b22da72e3eef7caca3985b874bf393dc2e448b339668971"></a>ARM_STORAGE_OPERATION_INITIALIZE</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ga3a9277f89946d61c41b22da72e3eef7cab9488e567ad58b16c5df2637df3902e9"></a>ARM_STORAGE_OPERATION_UNINITIALIZE</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ga3a9277f89946d61c41b22da72e3eef7ca213a74ac5a692a80f17fd6d8e6565e05"></a>ARM_STORAGE_OPERATION_POWER_CONTROL</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ga3a9277f89946d61c41b22da72e3eef7ca177812f3cb27c413473d94ebe9480454"></a>ARM_STORAGE_OPERATION_READ_DATA</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ga3a9277f89946d61c41b22da72e3eef7ca586b4774a7a092d1932d3415cc42abb0"></a>ARM_STORAGE_OPERATION_PROGRAM_DATA</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ga3a9277f89946d61c41b22da72e3eef7cab52a1d10b8087452fd97af8cdb9a6f75"></a>ARM_STORAGE_OPERATION_ERASE</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ga3a9277f89946d61c41b22da72e3eef7ca60a0511bd5e32db2a22d3ab2023a601e"></a>ARM_STORAGE_OPERATION_ERASE_ALL</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ga3a9277f89946d61c41b22da72e3eef7ca7c595cd3c439753efe0a0b17efd7bb7f"></a>ARM_STORAGE_OPERATION_GET_STATUS</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ga3a9277f89946d61c41b22da72e3eef7ca0fe0ef7c0a9e69d053a0419282248f40"></a>ARM_STORAGE_OPERATION_GET_INFO</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ga3a9277f89946d61c41b22da72e3eef7ca3292512d0222e4119d0cdf77de1508df"></a>ARM_STORAGE_OPERATION_RESOLVE_ADDRESS</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ga3a9277f89946d61c41b22da72e3eef7ca9bfab6ee9caa3ace32338d4ef2d856f5"></a>ARM_STORAGE_OPERATION_GET_NEXT_BLOCK</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ga3a9277f89946d61c41b22da72e3eef7cac75096931c3d29af1029f25fc44e7523"></a>ARM_STORAGE_OPERATION_GET_BLOCK</em>&#160;</td><td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="gaf28193431b1a2ee64b22bfb36aed27e3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__common__drv__gr.html#structARM__DRIVER__VERSION">ARM_DRIVER_VERSION</a> ARM_Storage_GetVersion </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get driver version. </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__common__drv__gr.html#structARM__DRIVER__VERSION">ARM_DRIVER_VERSION</a></dd></dl>
<p>The function <b>ARM_Storage_GetVersion</b> returns version information of the driver implementation in <a class="el" href="group__common__drv__gr.html#structARM__DRIVER__VERSION">ARM_DRIVER_VERSION</a>.</p>
<ul>
<li>API version is the version of the CMSIS-Driver specification used to implement this driver.</li>
<li>Driver version is source code version of the actual driver implementation.</li>
</ul>
<p>Example: </p>
<div class="fragment"><div class="line"><span class="keyword">extern</span> <a class="code" href="group__storage__interface__gr.html#structARM__DRIVER__STORAGE">ARM_DRIVER_STORAGE</a> *drv_info;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> read_version (<span class="keywordtype">void</span>)  {</div>
<div class="line">  <a class="code" href="group__common__drv__gr.html#structARM__DRIVER__VERSION">ARM_DRIVER_VERSION</a>  version;</div>
<div class="line"> </div>
<div class="line">  version = drv_info-&gt;<a class="code" href="group__storage__interface__gr.html#a8834b281da48583845c044a81566c1b3">GetVersion</a> ();</div>
<div class="line">  <span class="keywordflow">if</span> (version.<a class="code" href="group__common__drv__gr.html#ad180da20fbde1d3dafc074af87c19540">api</a> &lt; 0x10A)   {      <span class="comment">// requires at minimum API version 1.10 or higher</span></div>
<div class="line">    <span class="comment">// error handling</span></div>
<div class="line">    <span class="keywordflow">return</span>;</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>This API returns synchronously&ndash;it does not result in an invocation of a completion callback.</dd>
<dd>
The function GetVersion() can be called any time to obtain the required information from the driver (even before initialization). It always returns the same information. </dd></dl>

</div>
</div>
<a class="anchor" id="ga8378b3901dfe76d8f31728a50e10dae2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__storage__interface__gr.html#structARM__STORAGE__CAPABILITIES">ARM_STORAGE_CAPABILITIES</a> ARM_Storage_GetCapabilities </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get driver capabilities. </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__storage__interface__gr.html#structARM__STORAGE__CAPABILITIES">ARM_STORAGE_CAPABILITIES</a></dd></dl>
<p>The function <b>ARM_Storage_GetCapabilities</b> returns information about capabilities in this driver implementation. The data fields of the struct <a class="el" href="group__storage__interface__gr.html#structARM__STORAGE__CAPABILITIES" title="Storage Driver API Capabilities. ">ARM_STORAGE_CAPABILITIES</a> encode various capabilities, for example if the device is able to execute operations asynchronously.</p>
<p>Example: </p>
<div class="fragment"><div class="line"><span class="keyword">extern</span> <a class="code" href="group__storage__interface__gr.html#structARM__DRIVER__STORAGE">ARM_DRIVER_STORAGE</a> *drv_info;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> read_capabilities (<span class="keywordtype">void</span>)  {</div>
<div class="line">  <a class="code" href="group__storage__interface__gr.html#structARM__STORAGE__CAPABILITIES">ARM_STORAGE_CAPABILITIES</a> drv_capabilities;</div>
<div class="line"> </div>
<div class="line">  drv_capabilities = drv_info-&gt;<a class="code" href="group__storage__interface__gr.html#abbfb3aa4b6adb4407de79221bf12cc55">GetCapabilities</a> ();</div>
<div class="line">  <span class="comment">// interrogate capabilities</span></div>
<div class="line"></div>
<div class="line">}</div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>This API returns synchronously&ndash;it does not result in an invocation of a completion callback.</dd>
<dd>
The function GetCapabilities() can be called any time to obtain the required information from the driver (even before initialization). It always returns the same information. </dd></dl>

</div>
</div>
<a class="anchor" id="gacc5dc090a35ac16caff8957030eaa174"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t ARM_Storage_Initialize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__storage__interface__gr.html#ga4b290224fea782e6d2ad06f541b28a98">ARM_Storage_Callback_t</a>&#160;</td>
          <td class="paramname"><em>callback</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize the Storage interface. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">callback</td><td>Pointer to <a class="el" href="group__storage__interface__gr.html#ga4b290224fea782e6d2ad06f541b28a98">ARM_Storage_Callback_t</a>. Caller-defined callback to be invoked upon command completion for asynchronous APIs (including the completion of initialization). Use a NULL pointer when no callback signals are required. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If asynchronous activity is launched, invocation ARM_DRIVER_OK, and the caller can expect to receive a callback in the future with a status value of ARM_DRIVER_OK or an error-code. In the case of synchronous execution, control returns after completion with a value of 1. Return values less than ARM_DRIVER_OK (0) signify errors.</dd></dl>
<p>The function <b>ARM_Storage_Initialize</b> is called when the middleware component starts operation. In addition to bringing the controller to a ready state, Initialize() receives a callback handler to be invoked upon completion of asynchronous operations.</p>
<p><a class="el" href="group__storage__interface__gr.html#gacc5dc090a35ac16caff8957030eaa174" title="Initialize the Storage interface. ">ARM_Storage_Initialize()</a> needs to be called explicitly before powering the peripheral using <a class="el" href="group__storage__interface__gr.html#ga979a2484bf05b2986de95a5d98307d54" title="Control the Storage interface power. ">ARM_Storage_PowerControl()</a>, and before initiating other accesses to the storage controller.</p>
<p>The function performs the following operations:</p>
<ul>
<li>Initializes the resources needed for the Storage interface.</li>
<li>Registers the <a class="el" href="group__storage__interface__gr.html#ga4b290224fea782e6d2ad06f541b28a98">ARM_Storage_Callback_t</a> callback function.</li>
</ul>
<p>To start working with a peripheral the functions ARM_Storage_Initialize and <a class="el" href="group__storage__interface__gr.html#ga979a2484bf05b2986de95a5d98307d54" title="Control the Storage interface power. ">ARM_Storage_PowerControl()</a> need to be called in this order: </p>
<div class="fragment"><div class="line">drv-&gt;<a class="code" href="group__nand__interface__gr.html#a28b29ab7b6114bb97175bd40d18854ac">Initialize</a> (...);              <span class="comment">// Allocate I/O pins</span></div>
<div class="line">drv-&gt;<a class="code" href="group__nand__interface__gr.html#aba8f1c8019af95ffe19c32403e3240ef">PowerControl</a> (<a class="code" href="Driver__Common_8h.html#ga47d6d7c31f88f3b8ae4aaf9d8444afa5abed52b77a9ce4775570e44a842b1295e">ARM_POWER_FULL</a>); <span class="comment">// Power up peripheral, setup IRQ/DMA</span></div>
</div><!-- fragment --><ul>
<li><a class="el" href="group__storage__interface__gr.html#gacc5dc090a35ac16caff8957030eaa174" title="Initialize the Storage interface. ">ARM_Storage_Initialize()</a> typically allocates the I/O resources (pins) for the peripheral. The function can be called multiple times; if the I/O resources are already initialized it performs no operation and just returns with ARM_DRIVER_OK.</li>
<li>ARM_Storage_PowerControl (ARM_POWER_FULL) sets the peripheral registers including interrupt (NVIC) and optionally DMA. The function can be called multiple times; if the registers are already set it performs no operation and just returns with ARM_DRIVER_OK.</li>
</ul>
<p>To stop working with a peripheral the functions <a class="el" href="group__storage__interface__gr.html#ga979a2484bf05b2986de95a5d98307d54" title="Control the Storage interface power. ">ARM_Storage_PowerControl()</a> and <a class="el" href="group__storage__interface__gr.html#ga1d14b15ddcda2836c6e3c1d0b5e60dca" title="De-initialize the Storage Interface. ">ARM_Storage_Uninitialize()</a> need to be called in this order: </p>
<div class="fragment"><div class="line">drv-&gt;<a class="code" href="group__nand__interface__gr.html#aba8f1c8019af95ffe19c32403e3240ef">PowerControl</a> (<a class="code" href="Driver__Common_8h.html#ga47d6d7c31f88f3b8ae4aaf9d8444afa5ab6f5becc85ebd51c3dd2524a95d2ca35">ARM_POWER_OFF</a>); <span class="comment">// Terminate any pending transfers, reset IRQ/DMA, power off peripheral</span></div>
<div class="line">drv-&gt;<a class="code" href="group__nand__interface__gr.html#adcf20681a1402869ecb5c6447fada17b">Uninitialize</a> (...);           <span class="comment">// Release I/O pins</span></div>
</div><!-- fragment --><p>The functions <a class="el" href="group__storage__interface__gr.html#ga979a2484bf05b2986de95a5d98307d54" title="Control the Storage interface power. ">ARM_Storage_PowerControl()</a> and <a class="el" href="group__storage__interface__gr.html#ga1d14b15ddcda2836c6e3c1d0b5e60dca" title="De-initialize the Storage Interface. ">ARM_Storage_Uninitialize()</a> always execute and can be used to put the peripheral into a Safe State, for example after any data transmission errors. To restart the peripheral in an error condition, you should first execute the Stop Sequence and then the Start Sequence.</p>
<dl class="section note"><dt>Note</dt><dd>This API may execute asynchronously if <a class="el" href="group__storage__interface__gr.html#a15ade4ca762bc6ce72d435a16febb4cc" title="Used to indicate if APIs like initialize, read, erase, program, etc. can operate in asynchronous mode...">ARM_STORAGE_CAPABILITIES::asynchronous_ops</a> is set. Asynchronous execution is optional even if 'asynchronous_ops' is set. </dd></dl>

</div>
</div>
<a class="anchor" id="ga1d14b15ddcda2836c6e3c1d0b5e60dca"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t ARM_Storage_Uninitialize </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>De-initialize the Storage Interface. </p>
<dl class="section return"><dt>Returns</dt><dd>If asynchronous activity is launched, an invocation returns ARM_DRIVER_OK, and the caller can expect to receive a callback in the future with a status value of ARM_DRIVER_OK or an error-code. In the case of synchronous execution, control returns after completion with a value of 1. Return values less than ARM_DRIVER_OK (0) signify errors.</dd></dl>
<p>It is called when the middleware component stops operation, and wishes to release the software resources used by the interface.</p>
<dl class="section note"><dt>Note</dt><dd>This API may execute asynchronously if <a class="el" href="group__storage__interface__gr.html#a15ade4ca762bc6ce72d435a16febb4cc" title="Used to indicate if APIs like initialize, read, erase, program, etc. can operate in asynchronous mode...">ARM_STORAGE_CAPABILITIES::asynchronous_ops</a> is set. Asynchronous execution is optional even if 'asynchronous_ops' is set. </dd></dl>

</div>
</div>
<a class="anchor" id="ga979a2484bf05b2986de95a5d98307d54"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t ARM_Storage_PowerControl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__common__drv__gr.html#ga47d6d7c31f88f3b8ae4aaf9d8444afa5">ARM_POWER_STATE</a>&#160;</td>
          <td class="paramname"><em>state</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Control the Storage interface power. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">state</td><td>Power state </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If asynchronous activity is launched, an invocation returns ARM_DRIVER_OK, and the caller can expect to receive a callback in the future with a status value of ARM_DRIVER_OK or an error-code. In the case of synchronous execution, control returns after completion with a value of 1. Return values less than ARM_DRIVER_OK (0) signify errors.</dd></dl>
<p>The function <b>ARM_Storage_PowerControl</b> operates the power modes of the Storage interface.</p>
<p>To start working with a peripheral the functions Initialize and PowerControl need to be called in this order: </p>
<div class="fragment"><div class="line">drv-&gt;<a class="code" href="group__nand__interface__gr.html#a28b29ab7b6114bb97175bd40d18854ac">Initialize</a> (...);                 <span class="comment">// Allocate I/O pins</span></div>
<div class="line">drv-&gt;<a class="code" href="group__nand__interface__gr.html#aba8f1c8019af95ffe19c32403e3240ef">PowerControl</a> (<a class="code" href="Driver__Common_8h.html#ga47d6d7c31f88f3b8ae4aaf9d8444afa5abed52b77a9ce4775570e44a842b1295e">ARM_POWER_FULL</a>);    <span class="comment">// Power up peripheral, setup IRQ/DMA</span></div>
</div><!-- fragment --><ul>
<li><a class="el" href="group__storage__interface__gr.html#gacc5dc090a35ac16caff8957030eaa174" title="Initialize the Storage interface. ">ARM_Storage_Initialize()</a> typically allocates the I/O resources (pins) for the peripheral. The function can be called multiple times; if the I/O resources are already initialized it performs no operation and just returns with ARM_DRIVER_OK.</li>
<li>PowerControl (ARM_POWER_FULL) sets the peripheral registers including interrupt (NVIC) and optionally DMA. The function can be called multiple times; if the registers are already set it performs no operation and just returns with ARM_DRIVER_OK.</li>
</ul>
<p>To stop working with a peripheral the functions PowerControl and Uninitialize need to be called in this order: </p>
<div class="fragment"><div class="line">drv-&gt;<a class="code" href="group__nand__interface__gr.html#aba8f1c8019af95ffe19c32403e3240ef">PowerControl</a> (<a class="code" href="Driver__Common_8h.html#ga47d6d7c31f88f3b8ae4aaf9d8444afa5ab6f5becc85ebd51c3dd2524a95d2ca35">ARM_POWER_OFF</a>);     <span class="comment">// Terminate any pending transfers, reset IRQ/DMA, power off peripheral</span></div>
<div class="line">drv-&gt;<a class="code" href="group__nand__interface__gr.html#adcf20681a1402869ecb5c6447fada17b">Uninitialize</a> (...);               <span class="comment">// Release I/O pins</span></div>
</div><!-- fragment --><p>The functions ARM_Storage_PowerControl and ARM_Storage_Uninitialize always execute and can be used to put the peripheral into a Safe State, for example after any data transmission errors. To restart the peripheral in an error condition, you should first execute the Stop Sequence and then the Start Sequence.</p>
<p>The parameter <em>state</em> can have the following values:</p>
<ul>
<li><a class="el" href="Driver__Common_8h.html#ga47d6d7c31f88f3b8ae4aaf9d8444afa5abed52b77a9ce4775570e44a842b1295e">ARM_POWER_FULL</a> : set-up the Storage device for data transfers, enable interrupts (NVIC) and optionally DMA. Can be called multiple times. If the device is already in this mode, then the function performs no operation and returns with <a class="el" href="group__execution__status.html#ga85752c5de59e8adeb001e35ff5be6be7">ARM_DRIVER_OK</a>.</li>
<li><a class="el" href="Driver__Common_8h.html#ga47d6d7c31f88f3b8ae4aaf9d8444afa5a9ef9e57cbcc948d0e22314e73dc8c434">ARM_POWER_LOW</a> : may use power saving. Returns <a class="el" href="group__execution__status.html#ga2efa59e480d82697795439220e6884e4">ARM_DRIVER_ERROR_UNSUPPORTED</a> when not implemented.</li>
<li><a class="el" href="Driver__Common_8h.html#ga47d6d7c31f88f3b8ae4aaf9d8444afa5ab6f5becc85ebd51c3dd2524a95d2ca35">ARM_POWER_OFF</a> : terminates any pending data transfers, disables peripheral, disables related interrupts and DMA.</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>This API may execute asynchronously if <a class="el" href="group__storage__interface__gr.html#a15ade4ca762bc6ce72d435a16febb4cc" title="Used to indicate if APIs like initialize, read, erase, program, etc. can operate in asynchronous mode...">ARM_STORAGE_CAPABILITIES::asynchronous_ops</a> is set. Asynchronous execution is optional even if 'asynchronous_ops' is set. </dd></dl>

</div>
</div>
<a class="anchor" id="gabaa24553c165add98020434c980b3ab4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t ARM_Storage_ReadData </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read data from Storage. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">addr</td><td>Data address. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">data</td><td>Pointer to a buffer storing the data read from Storage. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Number of bytes to read. The data buffer should be at least as large as this size. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If asynchronous activity is launched, an invocation returns ARM_DRIVER_OK, and the caller can expect to receive a callback in the future with the number of successfully transferred bytes passed in as the 'status' parameter. In the case of synchronous execution, control returns after completion with a positive transfer-count. Return values less than ARM_DRIVER_OK (0) signify errors.</dd></dl>
<p>Read the contents of a range of storage memory into a buffer supplied by the caller. The buffer is owned by the caller and should remain accessible for the lifetime of this command.</p>
<dl class="section note"><dt>Note</dt><dd>This API may execute asynchronously if <a class="el" href="group__storage__interface__gr.html#a15ade4ca762bc6ce72d435a16febb4cc" title="Used to indicate if APIs like initialize, read, erase, program, etc. can operate in asynchronous mode...">ARM_STORAGE_CAPABILITIES::asynchronous_ops</a> is set. Asynchronous execution is optional even if 'asynchronous_ops' is set. </dd></dl>

</div>
</div>
<a class="anchor" id="gabd20d561854c06918b0515b6c1bba230"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t ARM_Storage_ProgramData </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Program data to Storage. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">addr</td><td>This is the start address of the range to be written into. It needs to be aligned to the device's <em>program_unit</em> specified in <a class="el" href="group__storage__interface__gr.html#structARM__STORAGE__INFO">ARM_STORAGE_INFO</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>The source of the write operation. The buffer is owned by the caller and should remain accessible for the lifetime of this command. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>The number of bytes requested to be written. The buffer should be at least as large as this size. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>'size' should be a multiple of the device's 'program_unit' (see <a class="el" href="group__storage__interface__gr.html#structARM__STORAGE__INFO">ARM_STORAGE_INFO</a>). </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>If asynchronous activity is launched, an invocation returns ARM_DRIVER_OK, and the caller can expect to receive a callback in the future with the number of successfully transferred bytes passed in as the 'status' parameter. In the case of synchronous execution, control returns after completion with a positive transfer-count. Return values less than ARM_DRIVER_OK (0) signify errors.</dd></dl>
<p>Write the contents of a given memory buffer into a range of storage memory. In the case of flash memory, the destination range in storage memory typically has its contents in an erased state from a preceding erase operation. The source memory buffer is owned by the caller and should remain accessible for the lifetime of this command.</p>
<dl class="section note"><dt>Note</dt><dd>It is best for the middleware to write in units of 'optimal_program_unit' (<a class="el" href="group__storage__interface__gr.html#structARM__STORAGE__INFO">ARM_STORAGE_INFO</a>) of the device.</dd>
<dd>
This API may execute asynchronously if <a class="el" href="group__storage__interface__gr.html#a15ade4ca762bc6ce72d435a16febb4cc" title="Used to indicate if APIs like initialize, read, erase, program, etc. can operate in asynchronous mode...">ARM_STORAGE_CAPABILITIES::asynchronous_ops</a> is set. Asynchronous execution is optional even if 'asynchronous_ops' is set. </dd></dl>

</div>
</div>
<a class="anchor" id="gaceef4851d9181cce65c8b2d05f4429bc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t ARM_Storage_Erase </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Erase Storage range. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">addr</td><td>This is the start-address of the range to be erased. It must start at an 'erase_unit' boundary of the underlying block. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Size (in bytes) of the range to be erased. 'addr + size' must be aligned with the 'erase_unit' of the underlying block. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If the range to be erased doesn't align with the erase_units of the respective start and end blocks, ARM_DRIVER_ERROR_PARAMETER is returned. If any part of the range is protected, ARM_STORAGE_ERROR_PROTECTED is returned. If any part of the range is not erasable, ARM_STORAGE_ERROR_NOT_ERASABLE is returned. All such sanity-check failures result in the error code being returned synchronously and the storage bytes within the range remain unaffected. Otherwise the function executes in the following ways: If asynchronous activity is launched, an invocation returns ARM_DRIVER_OK, and the caller can expect to receive a callback in the future with the number of successfully erased bytes passed in as the 'status' parameter. In the case of synchronous execution, control returns after completion with a positive erase-count. Return values less than ARM_DRIVER_OK (0) signify errors.</dd></dl>
<p>This function erases a range of storage specified by [addr, addr + size). Both 'addr' and 'addr + size' should align with the 'erase_unit'(s) of the respective owning storage block(s) (see <a class="el" href="group__storage__interface__gr.html#structARM__STORAGE__BLOCK">ARM_STORAGE_BLOCK</a> and <a class="el" href="group__storage__interface__gr.html#structARM__STORAGE__BLOCK__ATTRIBUTES">ARM_STORAGE_BLOCK_ATTRIBUTES</a>). The range to be erased will have its contents returned to the un-programmed state&ndash; i.e. to <a class="el" href="group__storage__interface__gr.html#a902510dbedab116ab6a260a83fbd0f27">ARM_STORAGE_INFO::erased_value</a>, which is usually 1 to indicate the pattern of all ones: 0xFF.</p>
<dl class="section note"><dt>Note</dt><dd>This API may execute asynchronously if <a class="el" href="group__storage__interface__gr.html#a15ade4ca762bc6ce72d435a16febb4cc" title="Used to indicate if APIs like initialize, read, erase, program, etc. can operate in asynchronous mode...">ARM_STORAGE_CAPABILITIES::asynchronous_ops</a> is set. Asynchronous execution is optional even if 'asynchronous_ops' is set.</dd>
<dd>
Erase() may return a smaller (positive) value than the size of the requested range. The returned value indicates the actual number of bytes erased. It is the caller's responsibility to follow up with an appropriate request to complete the operation.</dd>
<dd>
in the case of a failed erase (except when ARM_DRIVER_ERROR_PARAMETER, ARM_STORAGE_ERROR_PROTECTED, or ARM_STORAGE_ERROR_NOT_ERASABLE is returned synchronously), the requested range should be assumed to be in an unknown state. The previous contents may not be retained. </dd></dl>

</div>
</div>
<a class="anchor" id="ga04e77387a3c628d6fc661e82f7daddaa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t ARM_Storage_EraseAll </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Erase complete Storage. </p>
<dl class="section return"><dt>Returns</dt><dd>If any part of the storage range is protected, ARM_STORAGE_ERROR_PROTECTED is returned. If any part of the storage range is not erasable, ARM_STORAGE_ERROR_NOT_ERASABLE is returned. All such sanity-check failures result in the error code being returned synchronously and the storage bytes within the range remain unaffected. Otherwise the function executes in the following ways: If asynchronous activity is launched, an invocation returns ARM_DRIVER_OK, and the caller can expect to receive a callback in the future with ARM_DRIVER_OK passed in as the 'status' parameter. In the case of synchronous execution, control returns after completion with a value of 1. Return values less than ARM_DRIVER_OK (0) signify errors.</dd></dl>
<p>This optional function erases the complete device. If the device does not support global erase then the function returns the error value <a class="el" href="group__execution__status.html#ga2efa59e480d82697795439220e6884e4">ARM_DRIVER_ERROR_UNSUPPORTED</a>. The data field <em>'erase_all'</em> = <span class="XML-Token">1</span> of the structure <a class="el" href="group__storage__interface__gr.html#structARM__STORAGE__CAPABILITIES">ARM_STORAGE_CAPABILITIES</a> encodes that <a class="el" href="group__storage__interface__gr.html#ga04e77387a3c628d6fc661e82f7daddaa">ARM_Storage_EraseAll</a> is supported.</p>
<dl class="section note"><dt>Note</dt><dd>This API may execute asynchronously if <a class="el" href="group__storage__interface__gr.html#a15ade4ca762bc6ce72d435a16febb4cc" title="Used to indicate if APIs like initialize, read, erase, program, etc. can operate in asynchronous mode...">ARM_STORAGE_CAPABILITIES::asynchronous_ops</a> is set. Asynchronous execution is optional even if 'asynchronous_ops' is set. </dd></dl>

</div>
</div>
<a class="anchor" id="ga29e7bfe78f41abb16973bdb4e0188a20"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__storage__interface__gr.html#structARM__STORAGE__STATUS">ARM_STORAGE_STATUS</a> ARM_Storage_GetStatus </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get Storage status. </p>
<dl class="section return"><dt>Returns</dt><dd>Storage status <a class="el" href="group__storage__interface__gr.html#structARM__STORAGE__STATUS">ARM_STORAGE_STATUS</a></dd></dl>
<p>Get the status of the current (or previous) command executed by the storage controller; stored in the structure <a class="el" href="group__storage__interface__gr.html#structARM__STORAGE__STATUS">ARM_STORAGE_STATUS</a>.</p>
<dl class="section note"><dt>Note</dt><dd>This API returns synchronously&ndash;it does not result in an invocation of a completion callback. </dd></dl>

</div>
</div>
<a class="anchor" id="gad557e8e6e33cd4528d398ecf4dddc747"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t ARM_Storage_GetInfo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__storage__interface__gr.html#structARM__STORAGE__INFO">ARM_STORAGE_INFO</a> *&#160;</td>
          <td class="paramname"><em>info</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get Storage information. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">info</td><td>A caller-supplied buffer capable of being filled in with an <a class="el" href="group__storage__interface__gr.html#structARM__STORAGE__INFO">ARM_STORAGE_INFO</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ARM_DRIVER_OK if a <a class="el" href="group__storage__interface__gr.html#structARM__STORAGE__INFO">ARM_STORAGE_INFO</a> structure containing top level metadata about the storage controller is filled into the supplied buffer, else an appropriate error value.</dd></dl>
<p>Get information about the Storage device; stored in the structure <a class="el" href="group__storage__interface__gr.html#structARM__STORAGE__INFO">ARM_STORAGE_INFO</a>.</p>
<dl class="section note"><dt>Note</dt><dd>It is the caller's responsibility to ensure that the buffer passed in is able to be initialized with a <a class="el" href="group__storage__interface__gr.html#structARM__STORAGE__INFO">ARM_STORAGE_INFO</a>.</dd>
<dd>
This API returns synchronously&ndash;it does not result in an invocation of a completion callback. </dd></dl>

</div>
</div>
<a class="anchor" id="ga5a1934750a51c74b8b0fea52588a3b9a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t ARM_Storage_ResolveAddress </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>addr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resolve an address relative to the storage controller into a memory address. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">addr</td><td>The address for which we want a resolution to the processor's physical address space. It is an offset from the start of the storage map maintained by the owning storage controller. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The resolved address in the processor's address space, else ARM_STORAGE_INVALID_ADDRESS.</dd></dl>
<p>Only applicable to devices with memory-mapped storage.</p>
<dl class="section note"><dt>Note</dt><dd>This API returns synchronously. The invocation should return quickly, and result in a resolved address. </dd></dl>

</div>
</div>
<a class="anchor" id="gad318f8cb38626cbeea1fcf36a0977c44"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t ARM_Storage_GetNextBlock </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__storage__interface__gr.html#structARM__STORAGE__BLOCK">ARM_STORAGE_BLOCK</a> *&#160;</td>
          <td class="paramname"><em>prev_block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__storage__interface__gr.html#structARM__STORAGE__BLOCK">ARM_STORAGE_BLOCK</a> *&#160;</td>
          <td class="paramname"><em>next_block</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Advance to the successor of the current block (iterator). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">prev_block</td><td>An existing block (iterator) within the same storage controller. The memory buffer holding this block is owned by the caller. This pointer may be NULL; if so, the invocation fills in the first block into the out parameter: 'next_block'. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">next_block</td><td>A caller-owned buffer large enough to be filled in with the following <a class="el" href="group__storage__interface__gr.html#structARM__STORAGE__BLOCK" title="A storage block is a range of memory with uniform attributes. ">ARM_STORAGE_BLOCK</a>. It is legal to provide the same buffer using 'next_block' as was passed in with 'prev_block'. It is also legal to pass a NULL into this parameter if the caller isn't interested in populating a buffer with the next block, i.e. if the caller only wishes to establish the presence of a next block. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ARM_DRIVER_OK if a valid next block is found (or first block, if prev_block is passed as NULL); upon successful operation, the contents of the next (or first) block are filled into the buffer pointed to by the parameter 'next_block' and <a class="el" href="Driver__Storage_8h.html#a955b1ca2ea24cfd3a8923731b581cfd4">ARM_STORAGE_VALID_BLOCK(next_block)</a> is guaranteed to be true. Upon reaching the end of the sequence of blocks (iterators), or in case the driver is unable to fetch information about the next (or first) block, an error (negative) value is returned and an invalid StorageBlock is populated into the supplied buffer. If prev_block is NULL, the first block is returned.</dd></dl>
<p>This helper function fetches (an iterator to) the next block (or the first block if 'prev_block' is passed in as NULL). In the failure case, a terminating, invalid block iterator is filled into the out parameter: 'next_block'. In combination with <a class="el" href="Driver__Storage_8h.html#a955b1ca2ea24cfd3a8923731b581cfd4">ARM_STORAGE_VALID_BLOCK</a>, it can be used to iterate over the sequence of blocks within the storage map:</p>
<div class="fragment"><div class="line"><a class="code" href="group__storage__interface__gr.html#structARM__STORAGE__BLOCK">ARM_STORAGE_BLOCK</a> block;</div>
<div class="line"><span class="keywordflow">for</span> (drv-&gt;GetNextBlock(NULL, &amp;block); <a class="code" href="Driver__Storage_8h.html#a955b1ca2ea24cfd3a8923731b581cfd4">ARM_STORAGE_VALID_BLOCK</a>(&amp;block); drv-&gt;GetNextBlock(&amp;block, &amp;block)) {</div>
<div class="line">    <span class="comment">// make use of block</span></div>
<div class="line">}</div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>This API returns synchronously&ndash;it does not result in an invocation of a completion callback. </dd></dl>

</div>
</div>
<a class="anchor" id="ga5fe9d27ce8afe65124dec62566114073"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t ARM_Storage_GetBlock </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__storage__interface__gr.html#structARM__STORAGE__BLOCK">ARM_STORAGE_BLOCK</a> *&#160;</td>
          <td class="paramname"><em>block</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the storage block (iterator) encompassing a given storage address. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">addr</td><td>Storage address in bytes. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">block</td><td>A caller-owned buffer large enough to be filled in with the <a class="el" href="group__storage__interface__gr.html#structARM__STORAGE__BLOCK" title="A storage block is a range of memory with uniform attributes. ">ARM_STORAGE_BLOCK</a> encapsulating the given address. This value can also be passed in as NULL if the caller isn't interested in populating a buffer with the block, if the caller only wishes to establish the presence of a containing storage block. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ARM_DRIVER_OK if a containing storage-block is found. In this case, if block is non-NULL, the buffer pointed to by it is populated with the contents of the storage block, i.e. if block is valid and a block is found, <a class="el" href="Driver__Storage_8h.html#a955b1ca2ea24cfd3a8923731b581cfd4">ARM_STORAGE_VALID_BLOCK(block)</a> would return true following this call. If there is no storage block containing the given offset, or in case the driver is unable to resolve an address to a storage-block, an error (negative) value is returned and an invalid StorageBlock is populated into the supplied buffer.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This API returns synchronously&ndash;it does not result in an invocation of a completion callback. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Wed Jul 10 2019 15:20:31 for CMSIS-Driver Version 2.7.1 by Arm Ltd. All rights reserved.
	<!--
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.6 
	-->
	</li>
  </ul>
</div>
</body>
</html>
